<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ribbon客户端负载均衡</title>
    <link href="/2022/01/04/Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2022/01/04/Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Ribbon负载均衡"><a href="#1、Ribbon负载均衡" class="headerlink" title="1、Ribbon负载均衡"></a>1、Ribbon负载均衡</h1><p>​    Netflixfa 发布的一个<strong>负载均衡器</strong>，有助于控制 HTTP 和 TCP客户端行为。   在 SpringCloud 中， Eureka一般配合Ribbon进行使用，Ribbon提供了客户端负载均衡的功能。</p><pre><code> Ribbon自动的从注册中心中获取服务提供者的 列表信息，并基于内置的负载均衡算法，请求服务</code></pre><span id="more"></span>  <h2 id="1-1-过程"><a href="#1-1-过程" class="headerlink" title="1.1 过程"></a>1.1 过程</h2><p><img src="/img/SpringCloud/ribbon01.png"></p><h2 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h2><p><img src="/img/SpringCloud/ribbon02.png"></p><h2 id="1-3-负载均衡策略"><a href="#1-3-负载均衡策略" class="headerlink" title="1.3 负载均衡策略"></a>1.3 负载均衡策略</h2><p>Ribbon的负载均衡规则是一个叫做<strong>IRule的接口</strong>来定义的，每一个子接口都是一种规则：</p><p><img src="/img/SpringCloud/ribbon03.png"></p><table><thead><tr><th>内置负载均衡规则类</th><th>规则描述</th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个<strong>权重</strong>值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td>ZoneAvoidanceRule</td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><h2 id="1-4-修改负载均衡规则"><a href="#1-4-修改负载均衡规则" class="headerlink" title="1.4 修改负载均衡规则"></a>1.4 修改负载均衡规则</h2><h3 id="1-4-1-代码方式-全局的"><a href="#1-4-1-代码方式-全局的" class="headerlink" title="1.4.1 代码方式(全局的)"></a>1.4.1 代码方式(全局的)</h3><p>在order-service中的OrderApplication类中，定义一个新的IRule</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">randomRule</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-2-配置文件方式（针对微服务）"><a href="#1-4-2-配置文件方式（针对微服务）" class="headerlink" title="1.4.2 配置文件方式（针对微服务）"></a>1.4.2 配置文件方式（针对微服务）</h3><p>在order-service的application.yml文件中，添加新的配置也可以修改规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br><span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule#</span> <span class="hljs-string">负载均衡规则</span><br></code></pre></td></tr></table></figure><h2 id="1-5-饥饿加载"><a href="#1-5-饥饿加载" class="headerlink" title="1.5 饥饿加载"></a>1.5 饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时</p><h3 id="开启饥饿加载"><a href="#开启饥饿加载" class="headerlink" title="开启饥饿加载"></a>开启饥饿加载</h3><h3 id="指定饥饿加载的微服务名称"><a href="#指定饥饿加载的微服务名称" class="headerlink" title="指定饥饿加载的微服务名称"></a>指定饥饿加载的微服务名称</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br><span class="hljs-attr">eager-load:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启饥饿加载</span><br>  <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment">#对指定的userservide这个服务饥饿加载</span><br></code></pre></td></tr></table></figure><h1 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h1><p><strong>Ribbon负载均衡规则</strong></p><ul><li><p>规则接口是IRule</p></li><li><p>默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询</p></li></ul><p><strong>负载均衡自定义方式</strong></p><ul><li><p>代码方式：配置灵活，但修改时需要重新打包发布</p></li><li><p>配置方式：直观，方便，无需重新打包发布，但是无法做全局配置</p></li></ul><p><strong>饥饿加载</strong></p><ul><li><p>开启饥饿加载</p></li><li><p>指定饥饿加载的微服务名称</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Ribbon</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eureka注册中心</title>
    <link href="/2022/01/03/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2022/01/03/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Eureka注册中心"><a href="#1、Eureka注册中心" class="headerlink" title="1、Eureka注册中心"></a>1、Eureka注册中心</h1><p>主管服务注册与发现，也就是微服务的名称注册到Eureka，就可以通过Eureka找到微服务，而不需要修改服务调用的配置文件。</p><span id="more"></span><h2 id="1-1-服务调用产生的问题"><a href="#1-1-服务调用产生的问题" class="headerlink" title="1.1 服务调用产生的问题"></a>1.1 服务调用产生的问题</h2><ul><li><p>服务消费者该如何获取服务提供者的地址信息？</p></li><li><p>如果有多个服务提供者，消费者该如何选择？</p></li><li><p>消费者如何得知服务提供者的健康状态？</p></li></ul><h2 id="1-2-Eureka作用"><a href="#1-2-Eureka作用" class="headerlink" title="1.2 Eureka作用"></a>1.2 Eureka作用</h2><img src="/img/SpringCloud/eureka01.png" alt="" style="zoom:50%;" /><ul><li><p>消费者该如何获取服务提供者具体信息？</p></li><li><ul><li>服务提供者启动时向eureka注册自己的信息</li><li>eureka保存这些信息</li></ul></li><li><ul><li>消费者根据服务名称向eureka拉取提供者信息</li></ul></li><li><p>如果有多个服务提供者，消费者该如何选择？</p></li><li><ul><li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li></ul></li><li><p>消费者如何感知服务提供者健康状态？</p></li><li><ul><li>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</li><li>eureka会更新记录服务列表信息，心跳不正常会被剔除</li></ul></li><li><ul><li>消费者就可以拉取到最新的信息</li></ul></li></ul><h3 id="1-2-1-总结"><a href="#1-2-1-总结" class="headerlink" title="1.2.1 总结"></a>1.2.1 总结</h3><p>在Eureka架构中，微服务角色有两类：</p><ul><li><p>EurekaServer：服务端，注册中心</p></li><li><ul><li>记录服务信息</li><li>心跳监控</li></ul></li><li><p>EurekaClient：客户端</p></li><li><ul><li>Provider：服务提供者，例如案例中的 user-service</li></ul></li><li><ul><li><ul><li>注册自己的信息到EurekaServer</li><li>每隔30秒向EurekaServer发送心跳</li></ul></li></ul></li><li><ul><li>consumer：服务消费者，例如案例中的 order-service</li></ul></li><li><ul><li><ul><li>根据服务名称从EurekaServer拉取服务列表</li><li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li></ul></li></ul></li></ul><h2 id="1-3-搭建EurekaServer"><a href="#1-3-搭建EurekaServer" class="headerlink" title="1.3 搭建EurekaServer"></a>1.3 搭建EurekaServer</h2><h3 id="1-3-1-引入eureka-server依赖"><a href="#1-3-1-引入eureka-server依赖" class="headerlink" title="1.3.1 引入eureka-server依赖"></a>1.3.1 引入eureka-server依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-2-添加-EnableEurekaServer注解"><a href="#1-3-2-添加-EnableEurekaServer注解" class="headerlink" title="1.3.2 添加@EnableEurekaServer注解"></a>1.3.2 添加@EnableEurekaServer注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaServerApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-3-在application-yml中配置eureka地址"><a href="#1-3-3-在application-yml中配置eureka地址" class="headerlink" title="1.3.3 在application.yml中配置eureka地址"></a>1.3.3 在application.yml中配置eureka地址</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span>   <span class="hljs-comment">#端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment">#服务名称</span><br><span class="hljs-comment">#配置eureka server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否将自己注册到服务注册中心</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否从eureka中获取注册信息</span><br>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment">#配置暴露给eureka Client 的请求地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><h2 id="1-4-服务注册"><a href="#1-4-服务注册" class="headerlink" title="1.4 服务注册"></a>1.4 服务注册</h2><h3 id="1-4-1-引入eureka-client依赖"><a href="#1-4-1-引入eureka-client依赖" class="headerlink" title="1.4.1 引入eureka-client依赖"></a>1.4.1 引入eureka-client依赖</h3><p>无论是消费者还是提供者，引入eureka-client依赖、知道eureka地址后，都可以完成服务注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eurekaClient依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-2-在application-yml中配置eureka地址"><a href="#1-4-2-在application-yml中配置eureka地址" class="headerlink" title="1.4.2 在application.yml中配置eureka地址"></a>1.4.2 在application.yml中配置eureka地址</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置eureka注册地址</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:9000/eureka</span><br></code></pre></td></tr></table></figure><h2 id="1-5-服务发现"><a href="#1-5-服务发现" class="headerlink" title="1.5 服务发现"></a>1.5 服务发现</h2><h3 id="1-5-1-引入eureka-client依赖"><a href="#1-5-1-引入eureka-client依赖" class="headerlink" title="1.5.1 引入eureka-client依赖"></a>1.5.1 引入eureka-client依赖</h3><h3 id="1-5-2-在application-yml中配置eureka地址"><a href="#1-5-2-在application-yml中配置eureka地址" class="headerlink" title="1.5.2 在application.yml中配置eureka地址"></a>1.5.2 在application.yml中配置eureka地址</h3><h3 id="1-5-3-给RestTemplate添加-LoadBalanced-负载均衡-注解"><a href="#1-5-3-给RestTemplate添加-LoadBalanced-负载均衡-注解" class="headerlink" title="1.5.3 给RestTemplate添加@LoadBalanced(负载均衡)注解"></a>1.5.3 给RestTemplate添加@LoadBalanced(负载均衡)注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*启动类中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-4-用服务提供者的服务名称远程调用"><a href="#1-5-4-用服务提供者的服务名称远程调用" class="headerlink" title="1.5.4 用服务提供者的服务名称远程调用"></a>1.5.4 用服务提供者的服务名称远程调用</h3><blockquote><p>点击<a href="https://github.com/cherishll-git/Cloud-Code/tree/master/SpringCloudEureka">这里</a>查看源码。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Eureka</tag>
      
      <tag>注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识SpringCloud与微服务</title>
    <link href="/2022/01/02/%E5%88%9D%E8%AF%86SpringCloud%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/01/02/%E5%88%9D%E8%AF%86SpringCloud%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>​    微服务架构在某种程度上实在SOA架构上的进一步发展</p><p>​    微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成<strong>一组</strong>小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。</p><p>​    服务之间采用<strong>轻量级</strong>的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被<strong>独立地部署</strong>到生产环境、类生产环境等。</p><span id="more"></span><h1 id="1、架构的了解"><a href="#1、架构的了解" class="headerlink" title="1、架构的了解"></a>1、架构的了解</h1><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><p>​    优点：开发简单，适用于小型应用</p><p>​    缺点：不易扩展和维护，代码耦合</p><img src="/img/SpringCloud/cloud01.png" alt="" style="zoom:25%;" /><h2 id="1-2-分布式架构特点"><a href="#1-2-分布式架构特点" class="headerlink" title="1.2 分布式架构特点"></a>1.2 分布式架构特点</h2><p>​    松耦合、扩展性好，但是架构复杂，难度大。适合大型互联网项目。</p><p>​    微服务：一种良好架构设计的分布式方案</p><p>​    有点：拆分粒度小、服务更独立、耦合度更低</p><p>​    缺点：架构非常复杂，运维、监控、部署难度提高</p><img src="/img/SpringCloud/cloud02.png" alt="" style="zoom:35%;" /><h2 id="1-3-微服务架构"><a href="#1-3-微服务架构" class="headerlink" title="1.3 微服务架构"></a>1.3 微服务架构</h2><p>​    单一职责：微服务<strong>拆分粒度</strong>更小，每一个服务都对应唯一的业务能力，做到<strong>单一职责</strong>，避免重复业务开发</p><p>​    面向服务：微服务对外<strong>暴露</strong>业务接口</p><p>​    自治：团队独立、技术独立、数据独立、部署独立</p><p>​    隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p><p>​    <strong>优点</strong>：拆分粒度更小、服务更独立、耦合度更低</p><p>​    <strong>缺点</strong>：架构非常复杂，运维、监控、部署难度提高</p><img src="/img/SpringCloud/cloud03.png" alt="" style="zoom:50%;" /><h1 id="2、微服务技术对比"><a href="#2、微服务技术对比" class="headerlink" title="2、微服务技术对比"></a>2、微服务技术对比</h1><p>在国内最知名的就是SpringCloud和阿里巴巴的Dubbo</p><table><thead><tr><th></th><th>Dubbo</th><th>SpringCloud</th><th>SpringCloudAlibaba</th></tr></thead><tbody><tr><td>注册中心</td><td>zookeeper、Redis</td><td>Eureka、Consul</td><td>Nacos、Eureka</td></tr><tr><td>服务远程调用</td><td>Dubbo协议</td><td>Feign（HTTP协议）</td><td>Dubbo、Feign</td></tr><tr><td>配置中心</td><td>无</td><td>SpringCloudConfig</td><td>Spring Cloud Config、Nacos</td></tr><tr><td>服务网关</td><td>无</td><td>SpringCloudGateway、zuul</td><td>SpringCloudGateway、Zuul</td></tr><tr><td>服务监控和保护</td><td>dubbo-admin，功能弱</td><td>Hystrix</td><td>Sentinel</td></tr></tbody></table><h2 id="2-1-SpringCloud"><a href="#2-1-SpringCloud" class="headerlink" title="2.1 SpringCloud"></a>2.1 SpringCloud</h2><p>SpringCloud是目前国内使用<strong>最广泛</strong>的微服务框架。<a href="https://spring.io/projects/spring-cloud">官网地址</a></p><p>SpringCloud集成了各种微服务功能组件，并<strong>基于SpringBoot</strong>实现了这些组件的自动装配，从而提供了良好的开箱即用体验：</p><p><img src="/img/SpringCloud/cloud04.png"></p><h3 id="2-1-1-SpringCloud与SpringBoot版本兼容关系："><a href="#2-1-1-SpringCloud与SpringBoot版本兼容关系：" class="headerlink" title="2.1.1 SpringCloud与SpringBoot版本兼容关系："></a>2.1.1 SpringCloud与SpringBoot版本兼容关系：</h3><table><thead><tr><th>Release Train</th><th>Boot Version</th></tr></thead><tbody><tr><td>2020.0.x aka llford</td><td>2.4.x</td></tr><tr><td>Hoxton</td><td>2.2.x,2.3.x(Starting with SR5)</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><h1 id="3、服务拆分与服务远程调用"><a href="#3、服务拆分与服务远程调用" class="headerlink" title="3、服务拆分与服务远程调用"></a>3、服务拆分与服务远程调用</h1><h2 id="3-1-服务拆分"><a href="#3-1-服务拆分" class="headerlink" title="3.1 服务拆分"></a>3.1 服务拆分</h2><p>​    <strong>单一职责：</strong>微服务需要根据业务模块拆分，做到单一职责,不要重复开发相同业务</p><p>​    <strong>面向服务</strong>：微服务可以将业务暴露为接口，供其它微服务使用</p><p>​    <strong>数据独立</strong>：不同微服务都应该有自己独立的数据库</p><h2 id="3-2-服务远程调用"><a href="#3-2-服务远程调用" class="headerlink" title="3.2 服务远程调用"></a>3.2 服务远程调用</h2><h3 id="3-2-1-基于RestTemplate发起Http请求"><a href="#3-2-1-基于RestTemplate发起Http请求" class="headerlink" title="3.2.1 基于RestTemplate发起Http请求"></a>3.2.1 基于RestTemplate发起Http请求</h3><p>http请求做远程调用是与语言无关的调用，只要知道对方的<strong>ip、端口、接口路径、请求参数</strong>即可。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBootAOP记录操作日志</title>
    <link href="/2021/12/31/SpringBootAOP%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    <url>/2021/12/31/SpringBootAOP%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><p>AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待</p><span id="more"></span><h2 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h2><p><strong>横切关注点</strong>：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p><p> <strong>Aspect(切面)</strong>: 通常是一个类，里面可以定义<strong>切入点</strong>和<strong>通知</strong></p><p> <strong>JointPoint(连接点)</strong>: 程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p><p><strong>Advice(通知)</strong>:AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)</p><p><strong>Pointcut(切入点)</strong>: 就是带有通知的连接点，在程序中主要体现为书写切入点表达式</p><p>**weave(织入)**：将切面应用到目标对象并导致代理对象创建的过程</p><p><strong>introduction(引入)<strong>：在不修改代码的前提下，引入可以在</strong>运行期</strong>为类动态地添加一些方法或字段</p><p>**AOP代理(AOP Proxy)**：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类</p><p><strong>目标对象(Target Object)</strong>: 包含连接点的对象。也被称作被通知或被代理对象。</p><h2 id="1-2-AOP使用场景"><a href="#1-2-AOP使用场景" class="headerlink" title="1.2 AOP使用场景"></a>1.2 AOP使用场景</h2><blockquote><p><em>Authentication 权限</em><br> <em>Caching 缓存</em><br> <em>Context passing 内容传递</em><br> <em>Error handling 错误处理</em><br> <em>Lazy loading　懒加载</em><br> <em>Debugging　　调试</em><br> <em>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</em><br> <em>Performance optimization　性能优化</em><br> <em>Persistence　　持久化</em><br> <em>Resource pooling　资源池</em><br> <em>Synchronization　同步</em><br> <em>Transactions 事务</em></p></blockquote><h1 id="2、AOP实现记录操作日志"><a href="#2、AOP实现记录操作日志" class="headerlink" title="2、AOP实现记录操作日志"></a>2、AOP实现记录操作日志</h1><h2 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h2><p>在Spring框架中，使用AOP配合自定义注解可以方便的实现用户操作的监控。首先搭建一个基本的Spring Boot Web环境<a href="https://mrbird.cc/%E5%BC%80%E5%90%AFSpring-Boot.html">开启Spring Boot</a>，然后引入必要依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- aop依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- oracle驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- druid数据源驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Mybatis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-自定义注解"><a href="#2-2-自定义注解" class="headerlink" title="2.2 自定义注解"></a>2.2 自定义注解</h2><p>定义一个方法级别的<code>@Log</code>注解，用于标注需要监控的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-创建表和实体"><a href="#2-3-创建表和实体" class="headerlink" title="2.3 创建表和实体"></a>2.3 创建表和实体</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sys_log(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> AUTO_INCREMENT,<br>username <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br>operation <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-type">time</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>),<br><span class="hljs-keyword">method</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),<br>params <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>),<br>ip <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>),<br>create_time datetime,<br><span class="hljs-keyword">primary</span> key(id) <span class="hljs-keyword">using</span> btree<br>)ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br>public class SysLog implements Serializable &#123;<br>    private <span class="hljs-type">int</span> id;<br>    private String username;<br>    private String operation;<br>    private <span class="hljs-type">int</span> <span class="hljs-type">time</span>;<br>    private String <span class="hljs-keyword">method</span>;<br>    private String params;<br>    private String ip;<br>    private <span class="hljs-type">Date</span> createTime;<br>    <br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>此处省略setter和getter方法<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-保存日志的方法"><a href="#2-4-保存日志的方法" class="headerlink" title="2.4 保存日志的方法"></a>2.4 保存日志的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysLogDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveSysLog</span><span class="hljs-params">(SysLog sysLog)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>SysLogMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.lyq.dao.SysLogDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveSysLog&quot;</span>&gt;</span><br>        insert into sys_log (username,operation,time,method,params,ip,create_time)<br>        values (#&#123;username&#125;,#&#123;operation&#125;,#&#123;time&#125;,#&#123;method&#125;,#&#123;params&#125;,#&#123;ip&#125;,#&#123;createTime&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-5-切面和切点"><a href="#2-5-切面和切点" class="headerlink" title="2.5 切面和切点"></a>2.5 切面和切点</h2><p>定义一个LogAspect类，使用<code>@Aspect</code>标注让其成为一个切面，切点为使用<code>@Log</code>注解标注的方法，使用<code>@Around</code>环绕通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SysLogDao sysLogDao;<br>    <br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.lyq.annotation.Log)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointCut</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pointCut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">long</span> beginTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 执行方法</span><br>            result = point.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 执行时长(毫秒)</span><br>        <span class="hljs-keyword">long</span> time = System.currentTimeMillis() - beginTime;<br>        <span class="hljs-comment">// 保存日志</span><br>        saveLog(point, time);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveLog</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        MethodSignature signature = (MethodSignature) joinPoint.getSignature();<br>        Method method = signature.getMethod();<br>        SysLog sysLog = <span class="hljs-keyword">new</span> SysLog();<br>        Log logAnnotation = method.getAnnotation(Log.class);<br>        <span class="hljs-keyword">if</span> (logAnnotation != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 注解上的描述</span><br>            sysLog.setOperation(logAnnotation.value());<br>        &#125;<br>        <span class="hljs-comment">// 请求的方法名</span><br>        String className = joinPoint.getTarget().getClass().getName();<br>        String methodName = signature.getName();<br>        sysLog.setMethod(className + <span class="hljs-string">&quot;.&quot;</span> + methodName + <span class="hljs-string">&quot;()&quot;</span>);<br>        <span class="hljs-comment">// 请求的方法参数值</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-comment">// 请求的方法参数名称</span><br>        LocalVariableTableParameterNameDiscoverer u = <span class="hljs-keyword">new</span> LocalVariableTableParameterNameDiscoverer();<br>        String[] paramNames = u.getParameterNames(method);<br>        <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span> &amp;&amp; paramNames != <span class="hljs-keyword">null</span>) &#123;<br>            String params = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                params += <span class="hljs-string">&quot;  &quot;</span> + paramNames[i] + <span class="hljs-string">&quot;: &quot;</span> + args[i];<br>            &#125;<br>            sysLog.setParams(params);<br>        &#125;<br>        <span class="hljs-comment">// 获取request</span><br>        HttpServletRequest request = HttpContextUtils.getHttpServletRequest();<br>        <span class="hljs-comment">// 设置IP地址</span><br>        sysLog.setIp(IPUtils.getIpAddr(request));<br>        <span class="hljs-comment">// 模拟一个用户名</span><br>        sysLog.setUsername(<span class="hljs-string">&quot;testUser&quot;</span>);<br>        sysLog.setTime((<span class="hljs-keyword">int</span>) time);<br>        sysLog.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>        <span class="hljs-comment">// 保存系统日志</span><br>        sysLogDao.saveSysLog(sysLog);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/SpringBootAOP-Log">这里</a>查看项目源码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot结合Mybatis+Druid多数据源</title>
    <link href="/2021/12/31/SpringBoot%E7%BB%93%E5%90%88Mybatis-Druid%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <url>/2021/12/31/SpringBoot%E7%BB%93%E5%90%88Mybatis-Druid%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1、分析"><a href="#1、分析" class="headerlink" title="1、分析"></a>1、分析</h2><p>在Spring中配置MyBatis SqlSessionFactory的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mybatis 的SqlSessionFactory --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所以实际上在Spring Boot中配置MyBatis多数据源的<strong>关键</strong>在于<strong>创建SqlSessionFactory</strong>的时候为其<strong>分配不同</strong>的<strong>数据源。</strong></p><h2 id="2、整合过程"><a href="#2、整合过程" class="headerlink" title="2、整合过程"></a>2、整合过程</h2><h3 id="2-1-引入相关依赖-pom-xml"><a href="#2-1-引入相关依赖-pom-xml" class="headerlink" title="2.1 引入相关依赖(pom.xml)"></a>2.1 引入相关依赖(pom.xml)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- oracle驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.oracle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ojdbc6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- druid数据源驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-多数据源配置"><a href="#2-2-多数据源配置" class="headerlink" title="2.2 多数据源配置"></a>2.2 多数据源配置</h3><h4 id="2-2-1-配置application-yml文件"><a href="#2-2-1-配置application-yml文件" class="headerlink" title="2.2.1 配置application.yml文件"></a>2.2.1 配置application.yml文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/web</span> <span class="hljs-comment">#访问路径以/web开始 如：localhost:8080/web/xxx </span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-comment">#数据库访问配置,使用druid数据源</span><br>      <span class="hljs-comment">#数据源1 mysql</span><br>      <span class="hljs-attr">mysql:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span> <span class="hljs-comment">#数据库访问配置，使用druid数据源</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span> <br>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test_dev</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>      <span class="hljs-comment">#数据源2 oracle</span><br>      <span class="hljs-attr">oracle:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">oracle.jdbc.driver.OracleDriver</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:oracle:thin:@localhost:1521:ORCL</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">scott</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">ABab12</span><br><br>      <span class="hljs-comment"># 连接池配置</span><br>      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">5</span> <span class="hljs-comment">#初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</span><br>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 最小连接池数量</span><br>      <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 最大连接池数量</span><br>      <span class="hljs-comment"># 连接等待超时时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降</span><br>      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">30000</span> <br>      <span class="hljs-comment"># 配置检测可以关闭的空闲连接间隔时间</span><br>      <span class="hljs-attr">time-between-eviction-runs-millis:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-comment"># 配置连接在池中的最小生存时间</span><br>      <span class="hljs-attr">min-evictable-idle-time-millis:</span> <span class="hljs-number">300000</span><br>      <span class="hljs-comment"># 验证数据库服务可用性的sql.用来检测连接是否有效的sql 因数据库方言而差, 例如 oracle 应该写成 SELECT 1 FROM DUAL</span><br>      <span class="hljs-attr">validation-query:</span> <span class="hljs-string">select</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-string">from</span> <span class="hljs-string">dual</span><br>      <span class="hljs-comment"># 申请连接时检测空闲时间，根据空闲时间再检测连接是否有效.建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRun</span><br>      <span class="hljs-attr">test-while-idle:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 申请连接时直接检测连接是否有效.申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</span><br>      <span class="hljs-attr">test-on-borrow:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 归还连接时检测连接是否有效.归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</span><br>      <span class="hljs-attr">test-on-return:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br>      <span class="hljs-attr">pool-prepared-statements:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">max-open-prepared-statements:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">max-pool-prepared-statement-per-connection-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-comment"># 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &#x27;wall&#x27;用于防火墙</span><br>      <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall</span><br>      <span class="hljs-comment"># Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔</span><br>      <span class="hljs-attr">aop-patterns:</span> <span class="hljs-string">com.lyq.servie.*</span><br><br><br>      <span class="hljs-comment"># WebStatFilter配置</span><br>      <span class="hljs-attr">web-stat-filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment"># 添加过滤规则</span><br>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/*</span><br>        <span class="hljs-comment"># 忽略过滤的格式</span><br>        <span class="hljs-attr">exclusions:</span> <span class="hljs-string">&#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span><br><br>      <span class="hljs-comment"># StatViewServlet配置</span><br>      <span class="hljs-attr">stat-view-servlet:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment"># 访问路径为/druid时，跳转到StatViewServlet</span><br>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/druid/*</span><br>        <span class="hljs-comment"># 是否能够重置数据</span><br>        <span class="hljs-attr">reset-enable:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-comment"># 需要账号密码才能访问控制台</span><br>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">druid</span><br>        <span class="hljs-attr">login-password:</span> <span class="hljs-string">druid123</span><br>        <span class="hljs-comment"># IP白名单</span><br>        <span class="hljs-comment"># allow: 127.0.0.1</span><br>        <span class="hljs-comment">#　IP黑名单（共同存在时，deny优先于allow）</span><br>        <span class="hljs-comment"># deny: 192.168.1.218</span><br><br>      <span class="hljs-comment"># 配置StatFilter</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">stat:</span><br>          <span class="hljs-attr">log-slow-sql:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-创建数据源配置类"><a href="#2-2-2-创建数据源配置类" class="headerlink" title="2.2.2 创建数据源配置类"></a>2.2.2 创建数据源配置类</h4><p>MysqlDataSourceConfig.java 与 OrclDataSourceConfig.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(basePackages = MysqlDataSourceConfig.PACKAGE, sqlSessionFactoryRef = &quot;mysqlSqlSessionFactory&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlDataSourceConfig</span> </span>&#123;<br>    <span class="hljs-comment">// mysqldao扫描路径</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PACKAGE = <span class="hljs-string">&quot;com.lyq.mysqldao&quot;</span>;<br>    <span class="hljs-comment">// mybatis mapper扫描路径</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAPPER_LOCATION = <span class="hljs-string">&quot;classpath:mapper/mysql/*.xml&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Primary</span> 标志这个Bean，如果存在多个同类Bean候选时，该bean被优先考虑。</span><br><span class="hljs-comment">     *          多数据源的时候，必须要有一个主数据源，采用<span class="hljs-doctag">@Primary</span>标志该Bean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@Bean(name = &quot;mysqlDataSource&quot;)</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;spring.datasource.druid.mysql&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">mysqlDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;mysqlTransactionManager&quot;)</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title">mysqlTransactionManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(mysqlDataSource());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;mysqlSqlSessionFactory&quot;)</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">mysqlSqlSessionFactory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@Qualifier(&quot;mysqlDataSource&quot;)</span> DataSource dataSource)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> SqlSessionFactoryBean sessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();<br>        sessionFactory.setDataSource(dataSource);<br>        <span class="hljs-comment">//如果不使用xml的方式配置mapper，则可以省去下面这行mapper location的配置。</span><br>        sessionFactory.setMapperLocations(<br>                <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver()<br>                        .getResources(MysqlDataSourceConfig.MAPPER_LOCATION));<br>        <span class="hljs-keyword">return</span> sessionFactory.getObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码配置了一个名为mysqlDataSource的数据源，对应application.yml中<em><strong>spring.datasource.druid.mysql*<strong>前缀配置的数据库。然后</strong>创建</strong>了一个名为</em>*mysqlSqlSessionFactory<strong>的Bean，并且注入了mysqldatasource。与此同时，还分别定了两个扫描路径PACKAGE和MAPPER_LOCATION，</strong>前者<strong>为Mysql数据库对应的</strong>mapper接口地址<strong>，</strong>后者<strong>为对应的</strong>mapper xml文件路径**。</p><p><em>@Primary</em>标志这个Bean如果在多个同类Bean候选时，该Bean优先被考虑。多数据源配置的时候，必须要有一个主数据源，用*@Primary*标志该Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(basePackages = OrclDataSourceConfig.PACKAGE,</span><br><span class="hljs-meta">sqlSessionFactoryRef = &quot;orclSqlSessionFactory&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrclDataSourceConfig</span> </span>&#123;<br><br><span class="hljs-comment">// oracledao扫描路径</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PACKAGE = <span class="hljs-string">&quot;com.lyq.orcldao&quot;</span>; <br><span class="hljs-comment">// mybatis mapper扫描路径</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAPPER_LOCATION = <span class="hljs-string">&quot;classpath:mapper/orcl/*.xml&quot;</span>;<br><br><span class="hljs-meta">@Bean(name = &quot;orcldatasource&quot;)</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;spring.datasource.druid.oracle&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">orclDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();<br>    &#125;<br><br><span class="hljs-meta">@Bean(name = &quot;orclTransactionManager&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title">oracleTransactionManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(orclDataSource());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;orclSqlSessionFactory&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">oracleSqlSessionFactory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@Qualifier(&quot;orcldatasource&quot;)</span> DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> SqlSessionFactoryBean sessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();<br>        sessionFactory.setDataSource(dataSource);<br>        <span class="hljs-comment">//如果不使用xml的方式配置mapper，则可以省去下面这行mapper location的配置。</span><br>        sessionFactory.setMapperLocations(<br>                <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver()<br>                .getResources(OrclDataSourceConfig.MAPPER_LOCATION));<br>        <span class="hljs-keyword">return</span> sessionFactory.getObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-配置Dao层接口"><a href="#2-3-配置Dao层接口" class="headerlink" title="2.3 配置Dao层接口"></a>2.3 配置Dao层接口</h3><p>分别在com.springboot.mysqldao路径和com.springboot.oracledao路径下创建两个mapper接口：</p><p>MysqlStudentMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MysqlStudentMapper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Student student)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Student student)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByIds</span><span class="hljs-params">(String sno)</span></span>;<br>    <span class="hljs-function">Student <span class="hljs-title">queryStudentById</span><span class="hljs-params">(String sno)</span></span>;<br>    List&lt;Map&lt;String, Object&gt;&gt; getAllStudents();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    OrclStudentMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrclStudentMapper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Student student)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Student student)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByIds</span><span class="hljs-params">(String sno)</span></span>;<br>    <span class="hljs-function">Student <span class="hljs-title">queryStudentById</span><span class="hljs-params">(String sno)</span></span>;<br>    List&lt;Map&lt;String, Object&gt;&gt; getAllStudents();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-创建Mapper接口对应的实现"><a href="#2-4-创建Mapper接口对应的实现" class="headerlink" title="2.4 创建Mapper接口对应的实现"></a>2.4 创建Mapper接口对应的实现</h3><p>在src/main/resource/mapper/mysql/路径下创建MysqlStudentMapper.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.lyq.mysqldao.MysqlStudentMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在src/main/resource/mapper/oracle/路径下创建OrclStudentMapper.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.lyq.orcldao.OrclStudentMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-控制层及业务层"><a href="#2-5-控制层及业务层" class="headerlink" title="2.5 控制层及业务层"></a>2.5 控制层及业务层</h3><p>不再赘述</p><h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><p>新建一些测试数据，运行SpringBoot应用，发起对应请求</p><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/SpringBootMutiDataSource">这里</a>查看示例代码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Druid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Druid</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自动装配</title>
    <link href="/2021/12/29/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <url>/2021/12/29/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    自动装配可简单理解为Spring自动读取配置类信息，并解析配置类中的Bean信息，然后将相关Bean初始化到IOC容器中。</p><span id="more"></span><h1 id="1、源码剖析"><a href="#1、源码剖析" class="headerlink" title="1、源码剖析"></a>1、源码剖析</h1><h2 id="1-1-查看springboot依赖"><a href="#1-1-查看springboot依赖" class="headerlink" title="1.1 查看springboot依赖"></a>1.1 查看springboot依赖</h2><p>以创建的SpringBoot项目为例。我们创建了maven项目，导入了<strong>springboot的依赖</strong>，只要是springboot项目，都有这个依赖</p><img src="/img/SpringBoot/autoconfig01.png" alt="autoconfig01" style="zoom:50%;" /><p>进入这个依赖：</p><img src="/img/SpringBoot/autoconfig02.png" alt="autoconfig01" style="zoom:50%;" /><p>这个里面还有一个父类的依赖，我们继续的进去：</p><img src="/img/SpringBoot/autoconfig03.png" alt="autoconfig01" style="zoom:50%;" /><p>就可以看到有各种各样的jar包，意思是只要导入一个springboot的版本依赖，他就会给你导入很多的jar包，我们使用哪个，拿出来就可以了，并且不需要写版本，因为父类已经给你控制了。</p><blockquote><p>spring-boot-dependencies: 核心依赖在父工程中</p></blockquote><p><strong>启动器</strong>：</p><p>​    说白了就是SpringBoot的启动场景，如spring-boot-starter-web，它会帮我们自动导入web环境所有依赖</p><p>​    springboot将所有的启动场景都变为一个个启动器</p><p>​    我们需要使用什么功能，只需要找到对应的启动器即可</p><h2 id="1-2-SpringBoot主程序"><a href="#1-2-SpringBoot主程序" class="headerlink" title="1.2 SpringBoot主程序"></a>1.2 SpringBoot主程序</h2><img src="/img/SpringBoot/autoconfig04.png" alt="autoconfig01" style="zoom:50%;" /><img src="/img/SpringBoot/autoconfig05.png" alt="autoconfig01" style="zoom:50%;" /><h3 id="1-2-1-SpringBootConfiguration注解"><a href="#1-2-1-SpringBootConfiguration注解" class="headerlink" title="1.2.1 SpringBootConfiguration注解"></a>1.2.1 SpringBootConfiguration注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该注解被<code>@Configuration</code>注解修饰。只要一个类被这个注解修饰了，那么这个类就是一个配置类。</p><p>而<code>@Configuration</code>注解又<strong>派生自</strong><code>@Component</code>注解，@Component注解表示被修饰的类是spring的一个组件</p><h3 id="1-2-2-EnableAutoConfiguration注解"><a href="#1-2-2-EnableAutoConfiguration注解" class="headerlink" title="1.2.2 EnableAutoConfiguration注解"></a>1.2.2 EnableAutoConfiguration注解</h3><p>名字的意思是 <strong>自动配置</strong>，我们走进去看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">//自动配置包，扫描并注册我们自己写的java类到spring容器</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><span class="hljs-comment">//向spring容器中注入AutoConfigurationImportSelector对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br><span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-1-AutoConfigurationPackage-注解"><a href="#1-2-2-1-AutoConfigurationPackage-注解" class="headerlink" title="1.2.2.1 AutoConfigurationPackage 注解"></a>1.2.2.1 AutoConfigurationPackage 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  查看AutoConfigurationPackages.Registrar.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>&#125;<br><span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));</code>这个代码中，其实就是完成了我们自己写的类的扫描。</p><p><code>new PackageImports(metadata).getPackageNames().toArray(new String[0])</code>获取到的是指定扫描包的路径，如果未明确指定，默认为主启动类所在的包名。</p><h4 id="1-2-2-2-分析AutoConfigurationImportSelector"><a href="#1-2-2-2-分析AutoConfigurationImportSelector" class="headerlink" title="1.2.2.2 分析AutoConfigurationImportSelector"></a>1.2.2.2 分析AutoConfigurationImportSelector</h4><p>这个类所做的，是将springboot提供好的自动配置装载进spring容器。</p><p>进入AutoConfigurationImportSelector查看源码。找到这个获取所有配置的方法：</p><img src="/img/SpringBoot/autoconfig06.png" alt="autoconfig01" style="zoom:50%;" /><img src="/img/SpringBoot/autoconfig07.png" alt="autoconfig01" style="zoom:50%;" /><p>这个返回的东西，是在哪里见过，在这里：</p><img src="/img/SpringBoot/autoconfig08.png" alt="autoconfig01" style="zoom:70%;" /><p>所以，springboot启动类的作用是：导入启动类下所有资源。</p><h3 id="1-2-3-spring-factories"><a href="#1-2-3-spring-factories" class="headerlink" title="1.2.3 spring.factories"></a>1.2.3 spring.factories</h3><img src="/img/SpringBoot/autoconfig09.png" alt="autoconfig01" style="zoom:70%;" /><p>​    就是从这个红框里面的文件夹下面导入东西，如果这个文件夹不在，那么就报出这个消息，这个消息的意思是没有这个文件夹，或者这个文件夹下面没东西。那么我们看看这个文件夹下面有什么呢？</p><p><img src="/img/SpringBoot/autoconfig10.png" alt="spring.factories"></p><p>一个路径，就是一个配置类，我们可以随便进入一个路径,例如我们进入<code>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">ValidationAutoConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-4-配置类是否生效"><a href="#1-2-4-配置类是否生效" class="headerlink" title="1.2.4 配置类是否生效"></a>1.2.4 配置类是否生效</h3><p>spring.factories 里面有很多的配置类的路径，对应的配置类有的却没有生效。那是由于缺少相关依赖，导致条件不足。</p><p>例如：进入<code>org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration</code></p><img src="/img/SpringBoot/autoconfig11.png" alt="autoconfig01" style="zoom:70%;" /><p>看见爆红，意思是这个依赖是没有加入，也就是start启动没有加入，只有在pom里面导入对应的依赖，才会加入，这个注解就是对依赖进行判断，只有pom里面导入了，判断成功之后才会加入</p><h1 id="2、模拟SpringBoot自动装配"><a href="#2、模拟SpringBoot自动装配" class="headerlink" title="2、模拟SpringBoot自动装配"></a>2、模拟SpringBoot自动装配</h1><p>新建一个Spring Boot工程，Spring Boot版本为2.3.9.RELEASE，<code>artifactId</code>为autoconfig，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示:</p><img src="/img/SpringBoot/autoconfig12.png" alt="autoconfig01" style="zoom:50%;" /><h2 id="2-1-模式注解"><a href="#2-1-模式注解" class="headerlink" title="2.1 模式注解"></a>2.1 模式注解</h2><p>Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code>等，它们都“派生”自<code>@Component</code>注解。我们都知道，凡是被<code>@Component</code>标注的类都会被Spring扫描并纳入到IOC容器中，那么由<code>@Component</code>派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要通过自定义模式注解来了解<code>@Component</code>的“派生性”和“层次性”。</p><h3 id="2-1-1-Component-派生性"><a href="#2-1-1-Component-派生性" class="headerlink" title="2.1.1 @Component 派生性"></a>2.1.1 @Component 派生性</h3><p>在<code>com.lyq</code>下新建<code>annotation</code>包，然后创建一个<code>FirstLevelService</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@FirstLevelService</span>为<span class="hljs-doctag">@Component</span>派生出来的模式注解:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Component</span></span><br><span class="hljs-comment"> *    |__ <span class="hljs-doctag">@Service</span></span><br><span class="hljs-comment"> *            |___ <span class="hljs-doctag">@FirstLevelService</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FirstLevelService &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>com.lyq</code>下新建<code>service</code>包，然后创建一个<code>TestService</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FirstLevelService</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>com.lyq</code>下新建<code>bootstrap</code>包，然后创建一个<code>ServiceBootStrap</code>类，用于测试注册<code>TestService</code>并从IOC容器中获取它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.lyq.service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServcieBootStrap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//拿到spring容器</span><br>        ConfigurableApplicationContext context = <span class="hljs-keyword">new</span> SpringApplicationBuilder(ServcieBootStrap.class).web(WebApplicationType.NONE).run(args);<br>        TestService testService = context.getBean(<span class="hljs-string">&quot;testService&quot;</span>, TestService.class);<br>        System.out.println(<span class="hljs-string">&quot;FisrtService Bean:&quot;</span> + testService);<br>        context.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行该类的main方法，控制台输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TestService</span> Bean:com.lyq.service.TestService@<span class="hljs-number">6</span>e<span class="hljs-number">6</span>f<span class="hljs-number">2380</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-Component-层次性"><a href="#2-1-2-Component-层次性" class="headerlink" title="2.1.2 @Component 层次性"></a>2.1.2 @Component 层次性</h3><p>我们在<code>com.lyq.annotation</code>路径下再创建一个<code>SecondLevelService</code>注解定义，该注解由上面的<code>@FirstLevelService</code>标注:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 层次性：</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Component</span></span><br><span class="hljs-comment"> *    |__ <span class="hljs-doctag">@Service</span></span><br><span class="hljs-comment"> *            |___ <span class="hljs-doctag">@FirstLevelService</span></span><br><span class="hljs-comment"> *                      |___ <span class="hljs-doctag">@SecondLevelService</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@FirstLevelService</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecondLevelService &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将<code>TestService</code>上的注解换成<code>@SecondLevelService</code>，然后再次运行<code>ServiceBootStrap</code>的main方法，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TestService Bean:com.lyq.service.TestService@1530c739<br></code></pre></td></tr></table></figure><p>可见结果也是成功的。</p><blockquote><p>这里有一点需要注意的是：<code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个value属性定义。</p></blockquote><h2 id="2-2-Enable模块驱动"><a href="#2-2-Enable模块驱动" class="headerlink" title="2.2 @Enable模块驱动"></a>2.2 @Enable模块驱动</h2><p><code>@Enable</code>模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过<code>@Enable</code>模块驱动，我们可以开启相应的模块功能。</p><p><code>@Enable</code>模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：</p><h3 id="2-2-1-注解驱动"><a href="#2-2-1-注解驱动" class="headerlink" title="2.2.1 注解驱动"></a>2.2.1 注解驱动</h3><h4 id="2-2-1-1-案例"><a href="#2-2-1-1-案例" class="headerlink" title="2.2.1.1 案例"></a>2.2.1.1 案例</h4><p>Spring中，基于注解驱动的示例可以查看<code>@EnableWebMvc</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>该注解通过<code>@Import</code>导入一个配置类`DelegatingWebMvcConfiguration</p><blockquote><p>基于注解驱动的<code>@Enable</code>模块驱动其实就是<strong>通过<code>@Import</code>来导入一个配置类</strong>，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</p></blockquote><h4 id="2-2-1-2-实现"><a href="#2-2-1-2-实现" class="headerlink" title="2.2.1.2 实现"></a>2.2.1.2 实现</h4><p>我们来定义一个基于注解驱动的<code>@Enable</code>模块驱动。</p><p>在<code>com.lyq</code>下新建<code>configuration</code>包，然后创建一个<code>HelloWorldConfiguration</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Hello word!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>com.lyq.annotation</code>下创建一个<code>EnableHelloWorld</code>注解定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(HelloWorldConfiguration.class)</span><span class="hljs-comment">//导入刚刚创建的配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableHelloWorld &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>着在<code>com.lyq.bootstrap</code>下创建一个<code>TestEnableBootstap</code>启动类来测试<code>@EnableHelloWorld</code>注解是否生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableHelloWorld</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEnableBootStrap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//拿到spring容器</span><br>        ConfigurableApplicationContext context = <span class="hljs-keyword">new</span> SpringApplicationBuilder(TestEnableBootStrap.class).web(WebApplicationType.NONE).run(args);<br>        String hello = context.getBean(<span class="hljs-string">&quot;hello&quot;</span>, String.class);<br>        System.out.println(<span class="hljs-string">&quot;hello Bean:&quot;</span> + hello);<br>        context.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行该类的main方法，控制台输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello Bean:Hello word!<br></code></pre></td></tr></table></figure><h3 id="2-2-2-接口编程"><a href="#2-2-2-接口编程" class="headerlink" title="2.2.2 接口编程"></a>2.2.2 接口编程</h3><h4 id="2-2-2-1-案例"><a href="#2-2-2-1-案例" class="headerlink" title="2.2.2.1 案例"></a>2.2.2.1 案例</h4><p>除了使用上面这个方式外，我们还可以通过接口编程的方式来实现<code>@Enable</code>模块驱动。Spring中，基于接口编程方式的有<code>@EnableCaching</code>注解，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(&#123;CachingConfigurationSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableCaching &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br><br>    <span class="hljs-function">AdviceMode <span class="hljs-title">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 2147483647</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>EnableCaching</code>注解通过<code>@Import</code>导入了<code>CachingConfigurationSelector</code>类，该类间接<strong>实现</strong>了**<code>ImportSelector</code>接口**，在 <a href="https://mrbird.cc/Spring-Bean-Regist.html">深入学习Spring组件注册</a> 中，我们曾介绍了可以通过<code>ImportSelector</code>来实现组件注册。</p><blockquote><p>所以通过接口编程实现<code>@Enable</code>模块驱动的本质是：通过**<code>@Import</code>来导入接口<code>ImportSelector</code>实现类**，该实现类里可以定义需要注册到IOC容器中的组件，以此实现相应模块对应组件的注册。</p></blockquote><h4 id="2-2-2-2-实现"><a href="#2-2-2-2-实现" class="headerlink" title="2.2.2.2 实现"></a>2.2.2.2 实现</h4><p>在<code>com.lyq</code>下新建<code>selector</code>包，然后在该路径下新建一个<code>HelloWorldImportSelector</code>实现<code>ImportSelector</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;HelloWorldConfiguration.class.getName()&#125;;<br>    &#125;<br><span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们修改<code>EnableHelloWorld</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-comment">//@Import(HelloWorldConfiguration.class)//注解驱动，导入一个配置类</span><br><span class="hljs-meta">@Import(HelloWorldImportSelector.class)</span><span class="hljs-comment">//接口编程，导入接口ImportSelector实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableHelloWorld &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行<code>TestEnableBootstap</code>的main方法，你会发现输出是一样的。</p><h2 id="2-3-自动装配"><a href="#2-3-自动装配" class="headerlink" title="2.3 自动装配"></a>2.3 自动装配</h2><h3 id="2-3-1-分析"><a href="#2-3-1-分析" class="headerlink" title="2.3.1 分析"></a>2.3.1 分析</h3><p>Spring Boot中的自动装配技术底层主要用到了下面这些技术:</p><ol><li>Spring 模式注解装配</li><li>Spring @Enable 模块装配</li><li>Spring 条件装配装（<a href="https://mrbird.cc/Spring-Bean-Regist.html">深入学习Spring组件注册</a>中有介绍）</li><li>Spring 工厂加载机制</li></ol><p>Spring 工厂加载机制的实现类为<code>SpringFactoriesLoader</code>，查看其源码：</p><img src="/img/SpringBoot/autoconfig13.png" alt="autoconfig01" style="zoom:50%;" /><p>该类的方法会读取META-INF目录下的spring.factories配置文件，我们查看spring-boot-autoconfigure-2.3.9.RELEASE.jar下的该文件。</p><p>当启动类被<code>@EnableAutoConfiguration</code>标注后，Spring会去扫描spring.factories中配置的所有类，看是否可以纳入到IOC容器中进行管理。</p><p>比如我们查看<code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code>的源码：</p><img src="/img/SpringBoot/autoconfig14.png" alt="autoconfig01" style="zoom:50%;" /><h3 id="2-3-2-实现"><a href="#2-3-2-实现" class="headerlink" title="2.3.2 实现"></a>2.3.2 实现</h3><p>新建一个配置类<code>HelloWorldAutoConfiguration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableHelloWorld</span><br><span class="hljs-meta">@ConditionalOnProperty(name=&quot;hello_world&quot;,havingValue = &quot;true&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在resources目录下新建META-INF目录，并创建spring.factories文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Auto Configure</span><br><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.lyq.configuration.HelloWorldAutoConfiguration</span><br></code></pre></td></tr></table></figure><p>接着在配置文件application.properties中添加<code>helloworld=true</code>配置:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hello_world</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>最后创建<code>EnableAutoConfigurationBootstrap</code>，测试下<code>HelloWorldAutoConfiguration</code>是否生效:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableAutoConfigurationBootstrap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConfigurableApplicationContext context = <span class="hljs-keyword">new</span> SpringApplicationBuilder(EnableAutoConfigurationBootstrap.class)<br>                .web(WebApplicationType.NONE)<br>                .run(args);<br>        String hello = context.getBean(<span class="hljs-string">&quot;hello&quot;</span>, String.class);<br>        System.out.println(<span class="hljs-string">&quot;hello Bean: &quot;</span> + hello);<br>        context.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行该main方法，控制台输出如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">hello Bean: Hello <span class="hljs-built_in">word</span>!<br></code></pre></td></tr></table></figure><h3 id="2-3-3-回顾"><a href="#2-3-3-回顾" class="headerlink" title="2.3.3 回顾"></a>2.3.3 回顾</h3><ol><li><p>Spring 的<strong>工厂加载机制</strong>会自动读取META-INF目录下spring.factories文件内容；</p></li><li><p>我们在spring.factories定义了：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>com<span class="hljs-selector-class">.lyq</span><span class="hljs-selector-class">.configuration</span>.HelloWorldAutoConfiguration<br></code></pre></td></tr></table></figure><p>我们在测试类上使用了<code>@EnableAutoConfiguration</code>注解标注，那么<code>HelloWorldAutoConfiguration</code>就会被Spring扫描，看是否符合要求，如果符合则纳入到IOC容器中；</p></li><li><p><code>HelloWorldAutoConfiguration</code>上的<code>@ConditionalOnProperty</code>的注解作用为：当配置文件中配置了<code>hello_world=true</code>（我们确实添加了这个配置，所以符合要求）则这个类符合扫描规则；<code>@EnableHelloWorld</code>注解是我们前面例子中自定义的模块驱动注解，其引入了hello这个Bean，所以IOC容器中便会存在hello这个Bean了；</p></li><li><p>通过上面的步骤，我们就可以通过上下文获取到hello这个Bean了。</p></li></ol><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/SpringBootAutoconfig">这里</a>查看源码。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot中使用缓存</title>
    <link href="/2021/12/23/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/"/>
    <url>/2021/12/23/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>​    在程序中可以使用缓存的技术来节省对数据库的开销。Spring Boot对缓存提供了很好的支持，我们几乎不用做过多的配置即可使用各种缓存实现。这里主要介绍Ehcache和Redis缓存实现。</p><span id="more"></span><h1 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h1><h2 id="1-1-搭建一个SpringBoot项目"><a href="#1-1-搭建一个SpringBoot项目" class="headerlink" title="1.1 搭建一个SpringBoot项目"></a>1.1 搭建一个SpringBoot项目</h2><p>项目结构如下图所示：</p><img src="D:\git-data\CherishLLBlog\source\img\SpringBoot\springbootcache01.png" style="zoom:50%;" /><p>然后yml中配置日志输出级别以观察SQL的执行情况：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com:</span><br>      <span class="hljs-attr">lyq:</span><br>        <span class="hljs-attr">mapper:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><blockquote><p>其中com.lyq.mapper为MyBatis的Mapper接口路径</p></blockquote><h2 id="1-2-编写测试方法"><a href="#1-2-编写测试方法" class="headerlink" title="1.2 编写测试方法"></a>1.2 编写测试方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@SpringBootTest(classes = CacheApplication.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentService studentService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Student student1 = <span class="hljs-keyword">this</span>.studentService.queryStuBySno(<span class="hljs-string">&quot;210&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;学号为[&quot;</span> + student1.getStuno() + <span class="hljs-string">&quot;]的学生姓名为：&quot;</span> + student1.getStuname());<br><br>        Student student2 = <span class="hljs-keyword">this</span>.studentService.queryStuBySno(<span class="hljs-string">&quot;210&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;学号为[&quot;</span> + student2.getStuno() + <span class="hljs-string">&quot;]的学生姓名为：&quot;</span> + student2.getStuname());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试运行<code>test()</code>方法，结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2021-12-23 15:52:32.532 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">23860</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span>  <span class="hljs-attr">Preparing:</span> <span class="hljs-string">select</span> <span class="hljs-string">*</span> <span class="hljs-string">from</span> <span class="hljs-string">student</span> <span class="hljs-string">where</span> <span class="hljs-string">stuno</span> <span class="hljs-string">=</span> <span class="hljs-string">?</span><br><span class="hljs-number">2021-12-23 15:52:32.853 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">23860</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span> <span class="hljs-attr">Parameters:</span> <span class="hljs-number">210</span><span class="hljs-string">(String)</span><br><span class="hljs-number">2021-12-23 15:52:32.894 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">23860</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">&lt;==</span>      <span class="hljs-attr">Total:</span> <span class="hljs-number">1</span><br><span class="hljs-string">学号210的学生姓名为：zhangsan</span><br><span class="hljs-number">2021-12-23 15:52:32.896 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">23860</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span>  <span class="hljs-attr">Preparing:</span> <span class="hljs-string">select</span> <span class="hljs-string">*</span> <span class="hljs-string">from</span> <span class="hljs-string">student</span> <span class="hljs-string">where</span> <span class="hljs-string">stuno</span> <span class="hljs-string">=</span> <span class="hljs-string">?</span><br><span class="hljs-number">2021-12-23 15:52:32.897 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">23860</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span> <span class="hljs-attr">Parameters:</span> <span class="hljs-number">210</span><span class="hljs-string">(String)</span><br><span class="hljs-number">2021-12-23 15:52:32.900 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">23860</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">&lt;==</span>      <span class="hljs-attr">Total:</span> <span class="hljs-number">1</span><br><span class="hljs-string">学号210的学生姓名为：zhangsan</span><br></code></pre></td></tr></table></figure><p>可发现第二个查询虽然和第一个查询完全一样，但其还是对数据库进行了查询。接下来引入缓存来改善这个结果</p><h1 id="2、使用缓存"><a href="#2、使用缓存" class="headerlink" title="2、使用缓存"></a>2、使用缓存</h1><h2 id="2-1-缓存注解使用"><a href="#2-1-缓存注解使用" class="headerlink" title="2.1 缓存注解使用"></a>2.1 缓存注解使用</h2><h3 id="2-1-1-引入依赖"><a href="#2-1-1-引入依赖" class="headerlink" title="2.1.1 引入依赖"></a>2.1.1 引入依赖</h3><p>要开启Spring Boot的缓存功能，需要在pom中引入<code>spring-boot-starter-cache</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-开启缓存"><a href="#2-1-2-开启缓存" class="headerlink" title="2.1.2 开启缓存"></a>2.1.2 开启缓存</h3><p>在Spring Boot入口类中加入<code>@EnableCaching</code>注解开启缓存功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(CacheApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-3-加入缓存注解"><a href="#2-1-3-加入缓存注解" class="headerlink" title="2.1.3 加入缓存注解"></a>2.1.3 加入缓存注解</h3><p>在StudentService接口中加入缓存注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheConfig(cacheNames = &quot;student&quot;)</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentService</span> </span>&#123;<br>    <span class="hljs-meta">@CachePut(key = &quot;#p0.sno&quot;)</span><br>    <span class="hljs-function">Student <span class="hljs-title">updateStu</span><span class="hljs-params">(Student student)</span></span>;<br><br>    <span class="hljs-meta">@CacheEvict(key = &quot;#p0&quot;, allEntries = true)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteStuBySno</span><span class="hljs-params">(String stuno)</span></span>;<br><br>    <span class="hljs-meta">@Cacheable(key = &quot;#p0&quot;)</span><br>    <span class="hljs-function">Student <span class="hljs-title">queryStuBySno</span><span class="hljs-params">(String stuno)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在StudentService接口中加入了<code>@CacheConfig</code>注解，queryStuBySno方法使用了注解<code>@Cacheable(key=&quot;#p0&quot;)</code>，即将id作为redis中的key值。当我们更新数据的时候，应该使用<code>@CachePut(key=&quot;#p0.sno&quot;)</code>进行缓存数据的更新，否则将查询到脏数据，因为该注解保存的是方法的返回值，所以这里应该返回Student。</p><p>其实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository(&quot;studentService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">updateStu</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        studentMapper.updateStu(student);<br>        <span class="hljs-keyword">return</span> studentMapper.queryStuBySno(student.getStuno());<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteStuBySno</span><span class="hljs-params">(String stuno)</span> </span>&#123;<br>        studentMapper.deleteStuBySno(stuno);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">queryStuBySno</span><span class="hljs-params">(String stuno)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> studentMapper.queryStuBySno(stuno);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再次执行测试类方法，执行结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2021-12-23 17:08:46.579 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">1468</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span>  <span class="hljs-attr">Preparing:</span> <span class="hljs-string">select</span> <span class="hljs-string">*</span> <span class="hljs-string">from</span> <span class="hljs-string">student</span> <span class="hljs-string">where</span> <span class="hljs-string">stuno</span> <span class="hljs-string">=</span> <span class="hljs-string">?</span><br><span class="hljs-number">2021-12-23 17:08:46.849 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">1468</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span> <span class="hljs-attr">Parameters:</span> <span class="hljs-number">210</span><span class="hljs-string">(String)</span><br><span class="hljs-number">2021-12-23 17:08:46.880 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">1468</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">&lt;==</span>      <span class="hljs-attr">Total:</span> <span class="hljs-number">1</span><br><span class="hljs-string">学号为[210]的学生姓名为：zhangsan</span><br><span class="hljs-string">学号为[210]的学生姓名为：zhangsan</span><br></code></pre></td></tr></table></figure><h2 id="2-2-缓存注解"><a href="#2-2-缓存注解" class="headerlink" title="2.2 缓存注解"></a>2.2 缓存注解</h2><p>在Spring Boot中可使用的缓存注解有：</p><h3 id="2-2-1-CacheConfig"><a href="#2-2-1-CacheConfig" class="headerlink" title="2.2.1 @CacheConfig"></a>2.2.1 <code>@CacheConfig</code></h3><p>主要用于配置该类中会用到的一些共用的缓存配置。在上面<code>@CacheConfig(cacheNames = &quot;student&quot;)</code>：配置了该数据访问对象中返回的内容将存储于名为student的缓存对象中，我们也可以不使用该注解，直接通过<code>@Cacheable</code>自己配置缓存集的名字来定义；</p><h3 id="2-2-2-Cacheable"><a href="#2-2-2-Cacheable" class="headerlink" title="2.2.2 @Cacheable"></a>2.2.2 <code>@Cacheable</code></h3><p>配置了queryStuBySno函数的返回值将被加入缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数：</p><ul><li><code>value</code>、<code>cacheNames</code>：两个等同的参数（cacheNames为Spring 4新增，作为value的别名），用于指定缓存存储的集合名。由于Spring 4中新增了<code>@CacheConfig</code>，因此在Spring 3中原本必须有的value属性，也成为非必需项了；</li><li><code>key</code>：缓存对象存储在Map集合中的key值，非必需，缺省按照函数的所有参数组合作为key值，若自己配置需使用SpEL表达式，比如：<code>@Cacheable(key = &quot;#p0&quot;)</code>：使用函数第一个参数作为缓存的key值，更多关于SpEL表达式的详细内容可<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">参考</a>；</li><li><code>condition</code>：缓存对象的条件，非必需，也需使用SpEL表达式，只有满足表达式条件的内容才会被缓存，比如：<code>@Cacheable(key = &quot;#p0&quot;, condition = &quot;#p0.length() &lt; 3&quot;)</code>，表示只有当第一个参数的长度小于3的时候才会被缓存；</li><li><code>unless</code>：另外一个缓存条件参数，非必需，需使用SpEL表达式。它不同于condition参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对result进行判断；</li><li><code>keyGenerator</code>：用于指定key生成器，非必需。若需要指定一个自定义的key生成器，我们需要去实现<code>org.springframework.cache.interceptor.KeyGenerator</code>接口，并使用该参数来指定；</li><li><code>cacheManager</code>：用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用；</li><li><code>cacheResolver</code>：用于指定使用那个缓存解析器，非必需。需通过org.springframework.cache.interceptor.CacheResolver接口来实现自己的缓存解析器，并用该参数指定；</li></ul><h3 id="2-2-3-CachePut"><a href="#2-2-3-CachePut" class="headerlink" title="2.2.3 @CachePut"></a>2.2.3 <code>@CachePut</code></h3><p>配置于函数上，能够根据参数定义条件来进行缓存，其缓存的是方法的返回值，它与<code>@Cacheable</code>不同的是，它每次都会真实调用函数，所以主要用于数据新增和修改操作上。它的参数与<code>@Cacheable</code>类似，具体功能可参考上面对<code>@Cacheable</code>参数的解析；</p><h3 id="2-2-4-CacheEvict"><a href="#2-2-4-CacheEvict" class="headerlink" title="2.2.4 @CacheEvict"></a>2.2.4 <code>@CacheEvict</code></h3><p>配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据。除了同<code>@Cacheable</code>一样的参数之外，它还有下面两个参数：</p><ul><li><code>allEntries</code>：非必需，默认为false。当为true时，会移除所有数据；</li><li><code>beforeInvocation</code>：非必需，默认为false，会在调用方法之后移除数据。当为true时，会在调用方法之前移除数据。</li></ul><h2 id="2-3-缓存实现"><a href="#2-3-缓存实现" class="headerlink" title="2.3 缓存实现"></a>2.3 缓存实现</h2><p>要使用Spring Boot的缓存功能，还需要提供一个缓存的具体实现。Spring Boot根据下面的顺序去侦测缓存实现：</p><ul><li>Generic</li><li>JCache (JSR-107)</li><li>EhCache 2.x</li><li>Hazelcast</li><li>Infinispan</li><li>Redis</li><li>Guava</li><li>Simple</li></ul><p>除了按顺序侦测外，我们也可以通过配置属性<code>spring.cache.type</code>来强制指定。</p><p>接下来主要介绍基于Redis和Ehcache的缓存实现。</p><h3 id="2-3-1-Redis"><a href="#2-3-1-Redis" class="headerlink" title="2.3.1 Redis"></a>2.3.1 Redis</h3><h4 id="2-3-1-1-Redis准备工作"><a href="#2-3-1-1-Redis准备工作" class="headerlink" title="2.3.1.1 Redis准备工作"></a>2.3.1.1 Redis准备工作</h4><p><a href="https://github.com/MicrosoftArchive/redis/releases">下载Redis</a>，Redis 支持 32 位和 64 位。这个需要系统平台的实际情况选择，这里我基于docker应用容器框架，拉取redis最新镜像，并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis #拉取镜像<br>docker run -p 6379:6379 -v $PWD/data:/data  -d redis:3.2 redis-server --appendonly yes #启动redis容器<br><br>docker exec -it redis01 bash  #进入redis容器<br>redis-cli#执行redis-cli客户端命令<br></code></pre></td></tr></table></figure><img src="D:\git-data\CherishLLBlog\source\img\SpringBoot\springbootcache02.png" style="zoom:50%;" /><h4 id="2-3-1-2-引入依赖"><a href="#2-3-1-2-引入依赖" class="headerlink" title="2.3.1.2 引入依赖"></a>2.3.1.2 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring-boot redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-1-3-配置redis"><a href="#2-3-1-3-配置redis" class="headerlink" title="2.3.1.3 配置redis"></a>2.3.1.3 配置redis</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>   <br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-comment"># Redis数据库索引（默认为0）</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># Redis服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-comment"># Redis服务器连接端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">pool:</span><br>      <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br>      <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>      <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>      <span class="hljs-comment"># 连接池中的最大空闲连接</span><br>      <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>      <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 连接超时时间（毫秒）</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>更多关于Spring Boot Redis可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html#">参考配置</a></p><h4 id="2-3-1-4-redis配置类"><a href="#2-3-1-4-redis配置类" class="headerlink" title="2.3.1.4 redis配置类"></a>2.3.1.4 redis配置类</h4><p>通常我们都使用Json序列化后存入Redis，而SpringBoot1.x和SpringBoot2.x版本在自定义<code>CacheManager</code>有很大的区别，需要自行研读源码。</p><p>在此简单说明，但不做源码详细分析。</p><p>在SpringBoot1.x中，<code>RedisCacheManager</code>是可以使用<code>RedisTemplate</code>作为参数注入的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> </span>&#123;<br>RedisCacheManager cacheManager = <span class="hljs-keyword">new</span> RedisCacheManager(redisTemplate);<br>    <span class="hljs-keyword">return</span> cacheManager;<br>&#125; <br></code></pre></td></tr></table></figure><p>但在SpringBoot2.x中，有很大的不同，<code>RedisCacheManager</code>构造器如下，已经无法再使用<code>RedisTemplate</code>进行构造</p><p><img src="D:\git-data\CherishLLBlog\source\img\SpringBoot\springbootcache03.png"></p><p>官方文档中：</p><p><img src="D:\git-data\CherishLLBlog\source\img\SpringBoot\springbootcache04.png"></p><p>说明现在配置<code>RedisCacheManager</code>需要一个<code>RedisCacheConfiguration</code>来作为配置对象，通过<code>RedisCacheConfiguration</code>这个对象来指定对应的序列化策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;<br>    <span class="hljs-comment">// 自定义缓存key生成策略</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title">keyGenerator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyGenerator() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, java.lang.reflect.Method method, Object... params)</span> </span>&#123;<br>                StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>                sb.append(target.getClass().getName());<br>                sb.append(method.getName());<br>                <span class="hljs-keyword">for</span> (Object obj : params) &#123;<br>                    sb.append(obj.toString());<br>                &#125;<br>                <span class="hljs-keyword">return</span> sb.toString();<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 缓存管理器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br><br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）</span><br>        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofDays(<span class="hljs-number">1</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br><br>        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000025216273">参考Redis的json序列化配置</a></p><h4 id="2-3-1-5-测试"><a href="#2-3-1-5-测试" class="headerlink" title="2.3.1.5 测试"></a>2.3.1.5 测试</h4><p>再次执行测试类方法，执行结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2021-12-24 14:48:38.169 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">10052</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span>  <span class="hljs-attr">Preparing:</span> <span class="hljs-string">select</span> <span class="hljs-string">*</span> <span class="hljs-string">from</span> <span class="hljs-string">student</span> <span class="hljs-string">where</span> <span class="hljs-string">stuno</span> <span class="hljs-string">=</span> <span class="hljs-string">?</span><br><span class="hljs-number">2021-12-24 14:48:38.660 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">10052</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">==&gt;</span> <span class="hljs-attr">Parameters:</span> <span class="hljs-number">210</span><span class="hljs-string">(String)</span><br><span class="hljs-number">2021-12-24 14:48:38.701 </span><span class="hljs-string">DEBUG</span> <span class="hljs-number">10052</span> <span class="hljs-string">---</span> [           <span class="hljs-string">main</span>] <span class="hljs-attr">c.l.mapper.StudentMapper.queryStuBySno   :</span> <span class="hljs-string">&lt;==</span>      <span class="hljs-attr">Total:</span> <span class="hljs-number">1</span><br><span class="hljs-string">学号为[210]的学生姓名为：zhangsan</span><br><span class="hljs-string">学号为[210]的学生姓名为：zhangsan</span><br></code></pre></td></tr></table></figure><p><img src="D:\git-data\CherishLLBlog\source\img\SpringBoot\springbootcache05.png"></p><h3 id="2-3-2-Ehcache"><a href="#2-3-2-Ehcache" class="headerlink" title="2.3.2 Ehcache"></a>2.3.2 Ehcache</h3><h4 id="2-3-2-1-引入依赖"><a href="#2-3-2-1-引入依赖" class="headerlink" title="2.3.2.1 引入依赖"></a>2.3.2.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- ehcache --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-2-新建ehcache-xml"><a href="#2-3-2-2-新建ehcache-xml" class="headerlink" title="2.3.2.2 新建ehcache.xml"></a>2.3.2.2 新建ehcache.xml</h4><p>在src/main/resources目录下新建ehcache.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;ehcache.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><br><span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;10000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;3600&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">maxEntriesLocalHeap</span>=<span class="hljs-string">&quot;2000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;3600&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">statistics</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="ehcache说明"><a href="#ehcache说明" class="headerlink" title="ehcache说明"></a>ehcache说明</h5><p>关于Ehcahe的一些说明：</p><ul><li><code>name</code>：缓存名称。</li><li><code>maxElementsInMemory</code>：缓存最大数目</li><li><code>maxElementsOnDisk</code>：硬盘最大缓存个数。</li><li><code>eternal</code>：对象是否永久有效，一但设置了，timeout将不起作用。</li><li><code>overflowToDisk</code>：是否保存到磁盘。</li><li><code>timeToIdleSeconds</code>:设置对象在失效前的允许闲置时间（单位：秒）。仅当<code>eternal=false</code>对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</li><li><code>timeToLiveSeconds</code>：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当<code>eternal=false</code>对象不是永久有效时使用，默认是0，也就是对象存活时间无穷大。</li><li><code>diskPersistent</code>：是否缓存虚拟机重启期数据，默认值为false。</li><li><code>diskSpoolBufferSizeMB</code>：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</li><li><code>diskExpiryThreadIntervalSeconds</code>：磁盘失效线程运行时间间隔，默认是120秒。</li><li><code>memoryStoreEvictionPolicy</code>：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</li><li><code>clearOnFlush</code>：内存数量最大时是否清除。</li><li><code>memoryStoreEvictionPolicy：Ehcache</code>的三种清空策略：<strong>FIFO</strong>，first in first out，这个是大家最熟的，先进先出。<strong>LFU</strong>， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。<strong>LRU</strong>，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</li></ul><h4 id="2-3-2-3-配置application-yml"><a href="#2-3-2-3-配置application-yml" class="headerlink" title="2.3.2.3 配置application.yml"></a>2.3.2.3 配置application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">ehcache:</span><br>      <span class="hljs-attr">config:</span> <span class="hljs-string">&#x27;classpath:ehcache.xml&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-4-测试"><a href="#2-3-2-4-测试" class="headerlink" title="2.3.2.4 测试"></a>2.3.2.4 测试</h4><p>对于Ehcache来说，更新方法加不加<code>@CachePut</code>注解，结果都一样。</p><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/SpringBootCache">这里</a>查看源码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos安装指南</title>
    <link href="/2021/12/16/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2021/12/16/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高</p><span id="more"></span><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><img src="/img/SpringCloud/nacos01.png" alt="nacos安装目录1" style="zoom:60%;" /><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p>application.properties文件，修改其中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><img src="/img/SpringCloud/nacos02.png" alt="nacos的bin目录" style="zoom:60%;" /><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><img src="/img/SpringCloud/nacos03.png" alt="nacos启动" style="zoom:60%;" /><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF">http://127.0.0.1:8848/nacos即可</a>:</p><img src="/img/SpringCloud/nacos04.png" alt="nacos登录页" style="zoom:40%;" /><p>默认的账号和密码都是nacos，进入后：</p><img src="/img/SpringCloud/nacos05.png" alt="nacos首页" style="zoom:50%;" /><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf jdk-8u144-linux-x64.tar.gz<br></code></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/<span class="hljs-built_in">local</span>/java<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>上传nacos-server-1.4.1.tar.gz：</p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rm -rf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>目录内部：</p><img src="/img/SpringCloud/nacos06.png" alt="nacos首页" style="zoom:50%;" /><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh -m standalone<br></code></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>注册中心</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义starterr</title>
    <link href="/2021/12/15/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2021/12/15/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>SpringBoot 最强大的功能就是把我们常用的场景抽取成了一个个starter（场景启动器），我们通过引入springboot 为我提供的这些场景启动器，我们再进行少量的配置就能使用相应的功能。即使是这样，springboot也不能囊括我们所有的使用场景，往往我们需要自定义starter，来简化我们对springboot的使用。</p><span id="more"></span><p>我们将这些可独立于业务代码之外的功配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可，SpringBoot为我们完成自动装配。</p><h1 id="2、自定义starter的命名规则"><a href="#2、自定义starter的命名规则" class="headerlink" title="2、自定义starter的命名规则"></a>2、自定义starter的命名规则</h1><p>SpringBoot提供的starter以<code>spring-boot-starter-xxx</code>的方式命名的。官方建议自定义的starter使用<code>xxx-spring-boot-starter</code>命名规则。以区分SpringBoot生态提供的starter。</p><h2 id="2-1-官方命名空间"><a href="#2-1-官方命名空间" class="headerlink" title="2.1 官方命名空间"></a>2.1 官方命名空间</h2><ul><li>前缀：spring-boot-starter-xxx</li><li>模式：spring-boot-starter-模块名</li><li>举例：spring-boot-starter-web、spring-boot-starter-jdbc</li></ul><h2 id="2-2-自定义命名空间"><a href="#2-2-自定义命名空间" class="headerlink" title="2.2 自定义命名空间"></a>2.2 <strong>自定义命名空间</strong></h2><ul><li>后缀：xxx-spring-boot-starter</li><li>模式：模块-spring-boot-starter</li><li>举例：mybatis-spring-boot-starter</li></ul><h1 id="3、自定义starter实现"><a href="#3、自定义starter实现" class="headerlink" title="3、自定义starter实现"></a>3、自定义starter实现</h1><h2 id="3-1-新建工程"><a href="#3-1-新建工程" class="headerlink" title="3.1 新建工程"></a>3.1 新建工程</h2><p>命名为demo-spring-boot-start</p><p>项目结构如下：</p><img src="/img/SpringBoot/starter01.png" alt="" style="zoom:50%;" /><h2 id="3-2-pom依赖"><a href="#3-2-pom依赖" class="headerlink" title="3.2 pom依赖"></a>3.2 pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lyq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot starter<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--spring默认使用yml中的配置，但有时候要用传统的xml或properties配置，就需要使用spring-boot-configuration-processor了--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入spring-boot-starter，所有starter的基本配合--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-3-定义配置信息映射的实体类"><a href="#3-3-定义配置信息映射的实体类" class="headerlink" title="3.3 定义配置信息映射的实体类"></a>3.3 定义配置信息映射的实体类</h2><p><code>@ConfigurationProperties(prefix = &quot;demo&quot;)</code> 它可以<strong>把相同前缀的配置信息通过配置项名称映射成实体类</strong>，比如我们这里指定 <code>prefix = &quot;demo&quot;</code> 这样，我们就能将以demo为前缀的配置项拿到了。</p><blockquote><p>ps：其实这个注解很强大，它<strong>不但能映射成String或基本类型的变量。还可以映射为List，Map等数据结构</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lyq.starter.properties;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoProperties</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String sayWhat;<br>    <span class="hljs-keyword">private</span> String toWho;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSayWhat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sayWhat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSayWhat</span><span class="hljs-params">(String sayWhat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sayWhat = sayWhat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToWho</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> toWho;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setToWho</span><span class="hljs-params">(String toWho)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.toWho = toWho;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-定义一个service"><a href="#3-4-定义一个service" class="headerlink" title="3.4 定义一个service"></a>3.4 定义一个service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lyq.starter.service;<br><br><span class="hljs-keyword">import</span> com.lyq.starter.properties.DemoProperties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    DemoProperties demoProperties;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DemoProperties <span class="hljs-title">getDemoProperties</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> demoProperties;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDemoProperties</span><span class="hljs-params">(DemoProperties demoProperties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.demoProperties = demoProperties;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;对&quot;</span> + demoProperties.getToWho() + <span class="hljs-string">&quot;说:“&quot;</span> + demoProperties.getSayWhat() + <span class="hljs-string">&quot;”&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-定义配置类"><a href="#3-5-定义配置类" class="headerlink" title="3.5 定义配置类"></a>3.5 定义配置类</h2><p>这里，我们将<code>DemoService</code>类定义为一个<strong>Bean</strong>，交给Ioc容器。</p><ul><li><p><code>@Configuration</code>声明一个类作为配置类，代替xml文件。ps:通常 <code>@Configuration</code> 和 <code>@Bean</code> 是一起使用的</p></li><li><p><code>@EnableConfigurationProperties</code> 注解。该注解是用来开启对3步骤中 <code>@ConfigurationProperties</code> 注解配置Bean的支持。</p><p>当然了，也可以在 <code>@ConfigurationProperties</code> 注解的类上添加 <code>@Configuration</code> 或者 <code>@Component</code> 注解</p></li><li><p><code>@ConditionalOnProperty</code> 注解控制 <code>@Configuration</code> 是否生效。简单来说也就是我们可以通过在yml配置文件中控制 <code>@Configuration</code> 注解的配置类是否生效。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lyq.starter.config;<br><br><span class="hljs-keyword">import</span> com.lyq.starter.properties.DemoProperties;<br><span class="hljs-keyword">import</span> com.lyq.starter.service.DemoService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(DemoProperties.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">        prefix = &quot;demo&quot;,</span><br><span class="hljs-meta">        name = &quot;isopen&quot;,</span><br><span class="hljs-meta">        havingValue = &quot;true&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAutoconfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DemoProperties demoProperties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DemoService <span class="hljs-title">demoService</span><span class="hljs-params">()</span></span>&#123;<br>        DemoService demoService = <span class="hljs-keyword">new</span> DemoService();<br>        demoService.setDemoProperties(demoProperties);<br>        <span class="hljs-keyword">return</span> demoService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-重点：创建spring-factories"><a href="#3-6-重点：创建spring-factories" class="headerlink" title="3.6 重点：创建spring.factories"></a>3.6 重点：创建spring.factories</h2><p>在resource目录下，新建META-INF文件夹，然后创建spring.factories文件。</p><p>目录结构如下：</p><img src="/img/SpringBoot/starter02.png" alt="" style="zoom:50%;" /><p>在该文件中加入如下配置，该配置指定上步骤中定义的配置类为自动装配的配置:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#指定自动装配的配置类</span><br><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">  com.lyq.starter.config.DemoAutoconfiguration</span><br></code></pre></td></tr></table></figure><h2 id="3-7-生成starter"><a href="#3-7-生成starter" class="headerlink" title="3.7 生成starter"></a>3.7 生成starter</h2><p>在demo-spring-boot-starter工程中，使用terminal终端执行<code>mvn clean</code>、<code>mvn install</code></p><img src="/img/SpringBoot/starter03.png" alt="" style="zoom:50%;" /><p><strong>或者</strong>直接点击运行maven插件：</p><img src="/img/SpringBoot/starter04.png" alt="" style="zoom:50%;" /><p>至此，一个自定义的starter新鲜出炉。（本人配置了mvn本地仓库，看下本地仓库中starter）：</p><img src="/img/SpringBoot/starter05.png" alt="" style="zoom:50%;" /><h2 id="3-8-测试"><a href="#3-8-测试" class="headerlink" title="3.8 测试"></a>3.8 测试</h2><h3 id="3-8-1-新建测试工程"><a href="#3-8-1-新建测试工程" class="headerlink" title="3.8.1 新建测试工程"></a>3.8.1 新建测试工程</h3><h3 id="3-8-2-引入自定义start依赖"><a href="#3-8-2-引入自定义start依赖" class="headerlink" title="3.8.2 引入自定义start依赖"></a>3.8.2 引入自定义start依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lyq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-8-3-配置application-yml"><a href="#3-8-3-配置application-yml" class="headerlink" title="3.8.3 配置application.yml"></a>3.8.3 配置application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">demo:</span><br>  <span class="hljs-attr">isopen:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">to-who:</span> <span class="hljs-string">李四</span><br>  <span class="hljs-attr">say-what:</span> <span class="hljs-string">自定义的starter测试成功</span><br></code></pre></td></tr></table></figure><h3 id="3-8-4-编写测试类"><a href="#3-8-4-编写测试类" class="headerlink" title="3.8.4 编写测试类"></a>3.8.4 编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lyq.controller;<br><br><span class="hljs-keyword">import</span> com.lyq.starter.service.DemoService;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterTestController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource(name = &quot;demoService&quot;)</span><br>    <span class="hljs-keyword">private</span> DemoService demoService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/say&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayWhat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> demoService.say(<span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-5-验证结果"><a href="#3-8-5-验证结果" class="headerlink" title="3.8.5 验证结果"></a>3.8.5 验证结果</h3><img src="/img/SpringBoot/starter06.png" alt="" style="zoom:50%;" /><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/demo-spring-boot-starter">这里</a>查看源码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI机制</title>
    <link href="/2021/12/09/SPI%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/12/09/SPI%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    <strong>SPI</strong> ，全称为 <strong>Service Provider Interface</strong>，是一种<strong>服务发现机制</strong>。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><span id="more"></span><p>Java SPI 实际上是<strong>“基于接口的编程＋策略模式＋配置文件”</strong>组合实现的<strong>动态加载机制</strong>。</p><h1 id="1、SPI具体约定"><a href="#1、SPI具体约定" class="headerlink" title="1、SPI具体约定"></a>1、SPI具体约定</h1><ul><li><p>当服务的提供者，提供了服务接口的一种实现之后，在jar包的<code>META-INF/services/</code>目录里目录下创建一个接口的<strong>全限定名</strong>的文件，该文件的内容是是实现类的全限定名；</p></li><li><p>当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p></li></ul><p>基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：<code>java.util.ServiceLoader</code></p><h1 id="2、JDK实现"><a href="#2、JDK实现" class="headerlink" title="2、JDK实现"></a>2、JDK实现</h1><h2 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h2><img src="/img/blogImg/spiProjectStruct.png" alt="" style="zoom:50%;" /><h2 id="2-2-SPI-Demo的代码："><a href="#2-2-SPI-Demo的代码：" class="headerlink" title="2.2 SPI Demo的代码："></a>2.2 SPI Demo的代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lyq.service;<br><span class="hljs-comment">//定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PayMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPayMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//两个实现类</span><br><span class="hljs-keyword">package</span> com.lyq.service.impl;<br><br><span class="hljs-keyword">import</span> com.lyq.service.PayMethod;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliPayMethod</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PayMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPayMethod</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;ali pay&quot;</span>);&#125;<br>&#125;<br><br>==============类分割线==================<br><br><span class="hljs-keyword">package</span> com.lyq.service.impl;<br><br><span class="hljs-keyword">import</span> com.lyq.service.PayMethod;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeChatPayMethod</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PayMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPayMethod</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;wechat pay&quot;</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后要在ClassPath路径下配置添加一个文件。文件名字是接口的<strong>全限定类名（com.lyq.service.PayMethod）</strong>，内容是<strong>实现类的全限定类名</strong>，多个实现类用<strong>换行符</strong>分隔。</p><p>com.lyq.service.PayMethod：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.lyq</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.AliPayMethod</span><br>com<span class="hljs-selector-class">.lyq</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span>.WeChatPayMethod<br></code></pre></td></tr></table></figure><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPIDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 直接实例化耦合度较高</span><br><span class="hljs-comment">         */</span><br>        PayMethod aliPayMethod = <span class="hljs-keyword">new</span> AliPayMethod();<br>        aliPayMethod.getPayMethod();<br>        PayMethod weChatPayMethod = <span class="hljs-keyword">new</span> WeChatPayMethod();<br>        weChatPayMethod.getPayMethod();<br>        System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 解耦灵活配置法</span><br><span class="hljs-comment">         */</span><br>        testSPI();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSPI</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//把我们的接口类型保存到ServiceLoader中 service变量</span><br>        <span class="hljs-comment">//创建了lazyIterator对象 （把我们的接口保存     保存我们的classLoader）</span><br>        ServiceLoader&lt;PayMethod&gt; load = ServiceLoader.load(PayMethod.class);<br><br>        <span class="hljs-comment">//或者Service.providers()方法获取我们的Iterator对象</span><br>        <span class="hljs-comment">//Iterator&lt;PayMethod&gt; iterator  = Service.providers(PayMethod.class);</span><br><br>        Iterator&lt;PayMethod&gt; iterator = load.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            PayMethod next = iterator.next();<br>            next.getPayMethod();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过spi机制也可以像我们new对象一样获取实例！</strong>执行结果如下：</p><blockquote><p>ali pay<br>wechat pay</p><p>==========================</p><p>ali pay<br>wechat pay</p></blockquote><h2 id="2-4-分析"><a href="#2-4-分析" class="headerlink" title="2.4 分析"></a>2.4 分析</h2><p><strong>为什么不直接new而是用spi实现呢？</strong></p><p>​        与我们java设计相关，系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则；实际用时AliPayMethod支付，如果觉得AliPay支付方式不实用，需要替换一种实现，比如将我们的AliPay支付换成WeChatPay支付，就需要修改代码。</p><p>为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p><p>Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。</p><h1 id="3、适用场景"><a href="#3、适用场景" class="headerlink" title="3、适用场景"></a>3、适用场景</h1><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</p><p>比较常见的例子：</p><ul><li>数据库驱动加载接口实现类的加载</li><li>JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载</li><li>SLF4J加载不同提供商的日志实现类</li></ul><p><strong>Spring</strong><br>Spring中大量使用了SPI, 比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等<br><strong>Dubbo</strong><br>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</p><h1 id="4、源码分析"><a href="#4、源码分析" class="headerlink" title="4、源码分析"></a>4、源码分析</h1><h2 id="4-1-ServiceLoader-load-为例"><a href="#4-1-ServiceLoader-load-为例" class="headerlink" title="4.1 ServiceLoader.load()为例"></a>4.1 ServiceLoader.load()为例</h2><h3 id="4-1-1-成员变量"><a href="#4-1-1-成员变量" class="headerlink" title="4.1.1 成员变量"></a>4.1.1 成员变量</h3><p>首先看看ServiceLoader类的签名类的<strong>成员变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLoader</span>&lt;<span class="hljs-title">S</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br><br><span class="hljs-comment">//指定的配置文件的路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">&quot;META-INF/services/&quot;</span>;<br><br>    <span class="hljs-comment">// 代表被加载的类或者接口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;<br><br>    <span class="hljs-comment">// 用于定位，加载和实例化providers的类加载器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;<br><br>    <span class="hljs-comment">// 创建ServiceLoader时采用的访问控制上下文</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;<br><br>     <span class="hljs-comment">// 缓存providers，按实例化的顺序排列</span><br>    <span class="hljs-keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 懒查找迭代器 (内部类，真正加载服务类)</span><br>    <span class="hljs-keyword">private</span> LazyIterator lookupIterator;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-2-Load"><a href="#4-1-2-Load" class="headerlink" title="4.1.2 Load"></a>4.1.2 Load</h3><p><code>ServiceLoader.load</code>方法内创建一个新的ServiceLoader，并实例化该类中的成员变量，主要包括四大步骤：</p><p>​    1、loader（ClassLoader类型，类加载器）</p><p>​    2、acc（AccessControlContext类型，访问控制器）</p><p>​    3、providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</p><p>​    4、lookupIterator(实现迭代器功能)</p><p>重要源码提炼如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>ClassLoader cl = Thread.currentThread().getContextClassLoader();<br><span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service,ClassLoader loader)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceLoader&lt;&gt;(service, loader);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ServiceLoader</span><span class="hljs-params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;<br>    <span class="hljs-comment">////要加载的接口</span><br>service = Objects.requireNonNull(svc, <span class="hljs-string">&quot;Service interface cannot be null&quot;</span>);<br>    <span class="hljs-comment">//类加载器</span><br>loader = (cl == <span class="hljs-keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;<br>    <span class="hljs-comment">//访问控制器</span><br>    acc = (System.getSecurityManager() != <span class="hljs-keyword">null</span>) ? AccessController.getContext() : <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//先清空</span><br>    providers.clear();<br>    <span class="hljs-comment">//实例化内部类</span><br>    lookupIterator = <span class="hljs-keyword">new</span> LazyIterator(service, loader);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-3-查找实现类"><a href="#4-1-3-查找实现类" class="headerlink" title="4.1.3 查找实现类"></a>4.1.3 查找实现类</h3><p>查找实现类和创建实现类的过程，都在<code>LazyIterator</code>完成。当我们调用<code>iterator.hasNext</code>和<code>iterator.next</code>方法的时候，<strong>实际上</strong>调用的都是<strong>LazyIterator的相应方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;S&gt;() &#123;<br>        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator();<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            f (knownProviders.hasNext())<br>                    <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点关注</strong><code>lookupIterator.hasNext()</code>方法，它最终会调用到<code>hasNextService</code>。读取<code>META-INF/services/</code>下的配置文件，获得所有能被实例化的类的名称，值得注意的是，<code>ServiceLoader</code>可以跨越jar包获取META-INF下的配置文件，具体加载配置的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br>    Class&lt;S&gt; service;<br>    ClassLoader loader;<br>    Enumeration&lt;URL&gt; configs = <span class="hljs-keyword">null</span>;<br>    Iterator&lt;String&gt; pending = <span class="hljs-keyword">null</span>;<br>    String nextName = <span class="hljs-keyword">null</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNextService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//第二次调用的时候，已经解析完成了，直接返回</span><br>        <span class="hljs-keyword">if</span> (nextName != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//META-INF/services/ 加上接口的全限定类名，就是文件服务类的文件</span><br>            <span class="hljs-comment">//META-INF/services/spi.WordParse</span><br>            String fullName = PREFIX + service.getName();<br>            <span class="hljs-comment">//将文件路径转成URL对象</span><br>            configs = loader.getResources(fullName);<br>        &#125;<br>        <span class="hljs-keyword">while</span> ((pending == <span class="hljs-keyword">null</span>) || !pending.hasNext()) &#123;<br>            <span class="hljs-comment">//解析URL文件对象，读取内容，最后返回</span><br>            pending = parse(service, configs.nextElement());<br>        &#125;<br>        <span class="hljs-comment">//拿到第一个实现类的类名</span><br>        nextName = pending.next();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 创建实例,见4.1.4</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-4-创建实例"><a href="#4-1-4-创建实例" class="headerlink" title="4.1.4 创建实例"></a>4.1.4 创建实例</h3><p>当然，调用next方法的时候，实际调用到的是<code>lookupIterator.nextService</code>。它通过反射的方式，创建实现类的实例并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!hasNextService()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        <span class="hljs-comment">//全限定类名</span><br>        String cn = nextName;<br>        nextName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//创建类的Class对象</span><br>        Class&lt;?&gt; c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>        <span class="hljs-comment">//通过newInstance实例化</span><br>        S p = service.cast(c.newInstance());<br>        <span class="hljs-comment">//放入集合，返回实例</span><br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5、Spring实现"><a href="#5、Spring实现" class="headerlink" title="5、Spring实现"></a>5、Spring实现</h1><p>JDK中使用的是ServiceLoader</p><p>spring使用的是SpringFactoriesLoader实现，在org.springframework.core.io.support包中</p><p>文件路路径不同，spring配置在MATE-INF/spring.factories中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取某个已定义接口的实现类，跟JDK的ServiceLoader SPI相似度为90%</span><br>List&lt;BeanInfoFactory&gt; beanInfoFactories = SpringFactoriesLoader.loadFactories(BeanInfoFactory.class, classLoader);<br></code></pre></td></tr></table></figure><p>Spring通过classpath下META-INF/spring.factories配置文件，找到需要实例化的类进行实例化，其读取配置文件方式与jdk一致，但是比jdk更优势的地方是能指定bean进行实例化</p><h1 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h1><h2 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h2><p>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，实现解耦。我们的应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式，让我们不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<code>Class.forName(“com.mysql.jdbc.Driver”)</code>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从这个指定的地方访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类。</p><h2 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h2><ul><li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/JavaSPI">这里</a>查看源码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2021/12/08/RabbitMQ/"/>
    <url>/2021/12/08/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="1、快速入门"><a href="#1、快速入门" class="headerlink" title="1、快速入门"></a>1、快速入门</h1><h2 id="1-1-安装RabbitMQ"><a href="#1-1-安装RabbitMQ" class="headerlink" title="1.1 安装RabbitMQ"></a>1.1 安装RabbitMQ</h2><h3 id="1-1-1-基于docker安装："><a href="#1-1-1-基于docker安装：" class="headerlink" title="1.1.1 基于docker安装："></a>1.1.1 基于docker安装：</h3><p><strong>下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull rabbitmq:3-management<br></code></pre></td></tr></table></figure><p><strong>启动MQ</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --hostname my-rabbit --name rabbitmq -e RABBITMQ_DEFAULT_USER=cherishll -e RABBITMQ_DEFAULT_PASS=123123 -p 15672:15672 -p 5672:5672 rabbitmq:3-management<br></code></pre></td></tr></table></figure><blockquote><p>–hostname 配置的主机名</p><p>-p 15672:15672 rabbitMQ管理平台的端口</p><p>-p 5672:5672 消息通信的端口</p></blockquote><p>启动后访问图形界面 localhost:15672</p><h3 id="1-1-2-MQ的基本结构"><a href="#1-1-2-MQ的基本结构" class="headerlink" title="1.1.2 MQ的基本结构"></a>1.1.2 MQ的基本结构</h3><p><img src="/img/blogImg/image-20210717162752376.png" alt="MQ基本结构"></p><h3 id="1-1-3-RabbitMQ中的角色"><a href="#1-1-3-RabbitMQ中的角色" class="headerlink" title="1.1.3 RabbitMQ中的角色"></a>1.1.3 RabbitMQ中的角色</h3><ul><li>publisher：生产者（负责发布消息）</li><li>consumer：消费者（负责订阅消息）</li><li>exchange：交换机，负责消息路由</li><li>queue：队列，负责接受并缓存消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="1-2-RabbitMQ消息模型"><a href="#1-2-RabbitMQ消息模型" class="headerlink" title="1.2 RabbitMQ消息模型"></a>1.2 RabbitMQ消息模型</h2><p>RabbitMQ<a href="https://www.rabbitmq.com/getstarted.html">官方</a>提供了5个不同的Demo示例，对应了不同的消息模型：</p><ul><li><p>基本消息队列（BasicQueue）</p></li><li><p>工作消息队列（WorkQueue）</p><p><img src="/img/blogImg/mqdemo01.png" alt="demo"></p></li></ul><p>发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：</p><ul><li><p>Fanout Exchange：广播</p></li><li><p>Direct Exchange：路由</p></li><li><p>Topic Exchange：主题</p><p><img src="/img/blogImg/mqdemo02.png" alt="demo02"></p></li></ul><h2 id="1-3-RabbitMQ入门案例"><a href="#1-3-RabbitMQ入门案例" class="headerlink" title="1.3 RabbitMQ入门案例"></a>1.3 RabbitMQ入门案例</h2><h3 id="1-3-1-Demo中的Hello-World案例"><a href="#1-3-1-Demo中的Hello-World案例" class="headerlink" title="1.3.1 Demo中的Hello World案例"></a>1.3.1 Demo中的Hello World案例</h3><h4 id="1-3-1-1项目结构"><a href="#1-3-1-1项目结构" class="headerlink" title="1.3.1.1项目结构"></a>1.3.1.1项目结构</h4><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>​    <img src="/img/blogImg/mqdemocode.png" alt="项目结构" style="zoom:50%;" /></p><p>​    父工程引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-1-2-简单队列模式的模型"><a href="#1-3-1-2-简单队列模式的模型" class="headerlink" title="1.3.1.2 简单队列模式的模型"></a>1.3.1.2 简单队列模式的模型</h4><p><img src="/img/blogImg/image-20210717163434647.png" alt="模型"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h4 id="1-3-1-3-publisher实现"><a href="#1-3-1-3-publisher实现" class="headerlink" title="1.3.1.3 publisher实现"></a>1.3.1.3 publisher实现</h4><ul><li><p>建立连接</p></li><li><p>创建Channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel发送消息</p></li><li><p>关闭连接和channel</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PublisherTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;cherishll&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123123&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        Connection connection = factory.newConnection();<br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 3.创建队列</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 4.发送消息</span><br>        String message = <span class="hljs-string">&quot;hello, rabbitmq!&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;发送消息成功：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br>        <span class="hljs-comment">// 5.关闭通道和连接</span><br>        channel.close();<br>        connection.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-1-4-consumer实现"><a href="#1-3-1-4-consumer实现" class="headerlink" title="1.3.1.4 consumer实现"></a>1.3.1.4 consumer实现</h4><ul><li>建立连接</li><li>创建Channel</li><li>利用channel声明队列</li><li>订阅消息<ul><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;cherishll&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123123&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        Connection connection = factory.newConnection();<br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 3.创建队列</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 4.订阅消息</span><br>        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">// 5.处理消息</span><br>                String message = <span class="hljs-keyword">new</span> String(body);<br>                System.out.println(<span class="hljs-string">&quot;接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-总结"><a href="#1-3-2-总结" class="headerlink" title="1.3.2 总结"></a>1.3.2 总结</h3><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="2、SpringAMQP"><a href="#2、SpringAMQP" class="headerlink" title="2、SpringAMQP"></a>2、SpringAMQP</h1><p>SpringAmqp的<a href="https://spring.io/projects/spring-amqp">官方地址</a></p><p>SpringAMQP是基于RabbitMQ封装的一套API规范，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。提供了模板来发送和接收消息，包含两个部分，其中spring-amqp是基础抽象类，spring-rabbit是底层的默认实现。</p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息 </li></ul><h2 id="2-1-Basic-Queue简单队列模型"><a href="#2-1-Basic-Queue简单队列模型" class="headerlink" title="2.1 Basic Queue简单队列模型"></a>2.1 Basic Queue简单队列模型</h2><h3 id="2-1-1-父工程引入AMQP依赖"><a href="#2-1-1-父工程引入AMQP依赖" class="headerlink" title="2.1.1 父工程引入AMQP依赖"></a>2.1.1 父工程引入AMQP依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-消息发送"><a href="#2-1-2-消息发送" class="headerlink" title="2.1.2 消息发送"></a>2.1.2 消息发送</h3><h4 id="2-1-2-1-配置application-yml"><a href="#2-1-2-1-配置application-yml" class="headerlink" title="2.1.2.1 配置application.yml"></a>2.1.2.1 配置application.yml</h4><p>​    首先配置MQ地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">cherishll</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h4 id="2-1-2-2-编写测试类"><a href="#2-1-2-2-编写测试类" class="headerlink" title="2.1.2.2 编写测试类"></a>2.1.2.2 编写测试类</h4><p>在publisher服务中，编写测试类SpringAMQPTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringAmqpTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSimpleQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        String message = <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-3-消息接收"><a href="#2-1-3-消息接收" class="headerlink" title="2.1.3 消息接收"></a>2.1.3 消息接收</h3><h4 id="2-1-3-1-配置application-yml"><a href="#2-1-3-1-配置application-yml" class="headerlink" title="2.1.3.1 配置application.yml"></a>2.1.3.1 配置application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">cherishll</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h4 id="2-1-3-2-编写Rabbit监听"><a href="#2-1-3-2-编写Rabbit监听" class="headerlink" title="2.1.3.2 编写Rabbit监听"></a>2.1.3.2 编写Rabbit监听</h4><p>在consumer服务的<code>cn.lyq.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringRabbitListener</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-4-测试"><a href="#2-1-4-测试" class="headerlink" title="2.1.4 测试"></a>2.1.4 测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="2-2-Work-Queue任务模型"><a href="#2-2-Work-Queue任务模型" class="headerlink" title="2.2 Work Queue任务模型"></a>2.2 Work Queue任务模型</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/img/blogImg/workQueue.png" alt="workQueue"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="2-2-1-消息发送"><a href="#2-2-1-消息发送" class="headerlink" title="2.2.1 消息发送"></a>2.2.1 消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        String message = <span class="hljs-string">&quot;hello, message_&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-comment">// 发送消息</span><br>            rabbitTemplate.convertAndSend(queueName, message + i);<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-消息接收"><a href="#2-2-2-消息接收" class="headerlink" title="2.2.2 消息接收"></a>2.2.2 消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenWorkQueue1</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">20</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenWorkQueue2</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="2-2-4-能者多劳"><a href="#2-2-4-能者多劳" class="headerlink" title="2.2.4 能者多劳"></a>2.2.4 能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5 总结"></a>2.2.5 总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="2-3-发布-订阅"><a href="#2-3-发布-订阅" class="headerlink" title="2.3 发布/订阅"></a>2.3 发布/订阅</h2><p>发布订阅的模型如图：</p><p><img src="/img/blogImg/publisherAndConsumer.png" alt="发布订阅"></p><p>可以看到，在订阅模型中，多了一个<strong>exchange角色</strong>，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="2-4-Fanout"><a href="#2-4-Fanout" class="headerlink" title="2.4 Fanout"></a>2.4 Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="/img/blogImg/fanout.png" alt="fanoutQueue"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 exc.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机exc.fanout</li></ul><h3 id="2-4-1-声明队列和交换机"><a href="#2-4-1-声明队列和交换机" class="headerlink" title="2.4.1 声明队列和交换机"></a>2.4.1 声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="/img/blogImg/image-20210717165552676.png" alt="声明"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutConfig</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 声明交换机</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Fanout类型交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">&quot;exc.fanout&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第1个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">fanoutQueue1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindingQueue1</span><span class="hljs-params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第2个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">fanoutQueue2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindingQueue2</span><span class="hljs-params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-4-2-消息发送"><a href="#2-4-2-消息发送" class="headerlink" title="2.4.2 消息发送"></a>2.4.2 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFanoutExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    String exchangeName = <span class="hljs-string">&quot;exc.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    String message = <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-3-消息接收"><a href="#2-4-3-消息接收" class="headerlink" title="2.4.3 消息接收"></a>2.4.3 消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenFanoutQueue1</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenFanoutQueue2</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="2-5-Direct"><a href="#2-5-Direct" class="headerlink" title="2.5 Direct"></a>2.5 Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/img/blogImg/directqueue.png" alt="directQueue"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向exc. direct发送消息</li></ol><h3 id="2-5-1-声明队列和交换机（基于注解）"><a href="#2-5-1-声明队列和交换机（基于注解）" class="headerlink" title="2.5.1 声明队列和交换机（基于注解）"></a>2.5.1 声明队列和交换机（基于注解）</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenDirectQueue1</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenDirectQueue2</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-2-消息发送"><a href="#2-5-2-消息发送" class="headerlink" title="2.5.2 消息发送"></a>2.5.2 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendDirectExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    String exchangeName = <span class="hljs-string">&quot;itcast.direct&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    String message = <span class="hljs-string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;red&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-3-总结"><a href="#2-5-3-总结" class="headerlink" title="2.5.3 总结"></a>2.5.3 总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@QueueBinding</li><li>@Queue</li><li>@Exchange</li></ul><h2 id="2-6-Topic"><a href="#2-6-Topic" class="headerlink" title="2.6 Topic"></a>2.6 Topic</h2><h3 id="2-6-1-说明"><a href="#2-6-1-说明" class="headerlink" title="2.6.1 说明"></a>2.6.1 说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>图示：</p><p> <img src="/img/blogImg/toppicQueue.png" alt="topicQueue"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><h4 id="2-6-1-1-案例需求："><a href="#2-6-1-1-案例需求：" class="headerlink" title="2.6.1.1 案例需求："></a>2.6.1.1 案例需求：</h4><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><h3 id="2-6-2-消息发送"><a href="#2-6-2-消息发送" class="headerlink" title="2.6.2 消息发送"></a>2.6.2 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * topicExchange</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendTopicExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    String exchangeName = <span class="hljs-string">&quot;exc.topic&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    String message = <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-3-消息接收"><a href="#2-6-3-消息接收" class="headerlink" title="2.6.3 消息接收"></a>2.6.3 消息接收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;china.#&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenTopicQueue1</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;#.news&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenTopicQueue2</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-4-总结"><a href="#2-6-4-总结" class="headerlink" title="2.6.4.总结"></a>2.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="2-7-消息转换器"><a href="#2-7-消息转换器" class="headerlink" title="2.7.消息转换器"></a>2.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="2-7-1-测试默认转换器"><a href="#2-7-1-测试默认转换器" class="headerlink" title="2.7.1.测试默认转换器"></a>2.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendMap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 准备消息</span><br>    Map&lt;String,Object&gt; msg = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    msg.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    msg.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;simple.queue&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-2-配置JSON转换器"><a href="#2-7-2-配置JSON转换器" class="headerlink" title="2.7.2.配置JSON转换器"></a>2.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="2-7-2-1-引入依赖"><a href="#2-7-2-1-引入依赖" class="headerlink" title="2.7.2.1 引入依赖"></a>2.7.2.1 引入依赖</h4><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-7-2-2-配置消息转换器"><a href="#2-7-2-2-配置消息转换器" class="headerlink" title="2.7.2.2 配置消息转换器"></a>2.7.2.2 配置消息转换器</h4><p>在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title">jsonMessageConverter</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>点击<a href="https://github.com/cherishll-git/MyRepo01/tree/master/SpringBootMQ">这里</a>查看源码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识MQ</title>
    <link href="/2021/12/07/%E5%88%9D%E8%AF%86MQ/"/>
    <url>/2021/12/07/%E5%88%9D%E8%AF%86MQ/</url>
    
    <content type="html"><![CDATA[<h1 id="1、同步通讯"><a href="#1、同步通讯" class="headerlink" title="1、同步通讯"></a>1、同步通讯</h1><p>​    <strong>同步与异步通讯</strong>：</p><p>​        微服务间通讯有同步和异步两种方式：</p><p>​        同步通讯：就像打电话，需要实时响应。</p><p>​        异步通讯：就像发邮件，不需要马上回复。</p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><p><strong>Feign调用</strong>就属于<strong>同步方式</strong>，虽然调用可以实时得到结果，但<strong>存在</strong>下面的<strong>问题</strong>：</p><ul><li>耦合度高。每次加入新的需求，都要修改原来的代码</li><li>性能下降。调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用时间的总和</li><li>浪费资源。调用链中的每个服务都在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li><li>级联失败。如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li></ul><p>同步调用的<strong>优点</strong>：</p><ul><li>时效性较强，可以立即得到结果</li></ul><h1 id="2、异步通讯"><a href="#2、异步通讯" class="headerlink" title="2、异步通讯"></a>2、异步通讯</h1><p>异步调用常见实现就是事件驱动模式。可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="/img/blogImg/broker.png" alt="事件驱动"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>事件驱动的优势：</p><ul><li>服务解耦。每个服务都可以灵活插拔，可替换</li><li>性能提升，吞吐量提高。无需等待订阅者处理完成，响应更快速</li><li>服务没有强依赖，不用担心级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>流量削峰。不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h1 id="4、MQ常用框架"><a href="#4、MQ常用框架" class="headerlink" title="4、MQ常用框架"></a>4、MQ常用框架</h1><p>MQ（messageQueue），消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的基本使用</title>
    <link href="/2021/12/06/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/06/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1、镜像操作"><a href="#1、镜像操作" class="headerlink" title="1、镜像操作"></a>1、镜像操作</h1><h2 id="1-1-镜像的相关命令"><a href="#1-1-镜像的相关命令" class="headerlink" title="1.1 镜像的相关命令"></a>1.1 镜像的相关命令</h2><p>​    镜像名称：一般分为两部分  [repository]:[tag]   【在没有指定tag时，默认是latest，代表最新版本的镜像】</p><p><img src="/img/blogImg/dockerImage.png" alt="镜像"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images      #查看镜像<br>docker rmi#删除镜像<br>docker pull#从服务拉取镜像<br>docker push#推送镜像到服务<br>docker save #保存镜像为压缩包<br>docker load#加载压缩包为镜像<br>docker build       #基于Dockerfile构建镜像<br></code></pre></td></tr></table></figure><h1 id="2、Docker的容器操作"><a href="#2、Docker的容器操作" class="headerlink" title="2、Docker的容器操作"></a>2、Docker的容器操作</h1><p><img src="/img/blogImg/dockerContiner.png" alt="容器操作"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.6#运行一个容器<br>--name #指定容器名称<br>  -p #指定端口映射<br>  -d 让容器后台运行<br>docker logs #查看容器日志命令，添加-f参数可以持续查看日志<br>docker ps #查看容器状态。添加-a参数查看所有状态的容器<br>docker exec -it [容器名] [要执行的命令] #进入容器执行<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">exec</span>命令可以进入容器修改文件，但是在容器内修改文件是不推荐的</span><br><span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it mn bash <span class="hljs-comment">## 其中bash是一个linux终端交互命令</span></span><br>docker rm  #不能删除运行中的容器，除非添加 -f 参数<br></code></pre></td></tr></table></figure><h2 id="2-1-运行redis容器"><a href="#2-1-运行redis容器" class="headerlink" title="2.1 运行redis容器"></a>2.1 运行redis容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 6379:6379 -v $PWD/data:/data  -d redis:3.2 redis-server --appendonly yes<br><span class="hljs-meta">#</span><span class="bash">-v <span class="hljs-variable">$PWD</span>/data:/data : 将主机中当前目录下的data挂载到容器的/data</span><br><span class="hljs-meta">#</span><span class="bash">redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-简单操作"><a href="#2-1-2-简单操作" class="headerlink" title="2.1.2 简单操作"></a>2.1.2 简单操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it redis bash  #进入redis容器<br>redis-cli#执行redis-cli客户端命令<br></code></pre></td></tr></table></figure><h1 id="3、Docker数据卷"><a href="#3、Docker数据卷" class="headerlink" title="3、Docker数据卷"></a>3、Docker数据卷</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>容器与数据耦合的问题：</p><ul><li>不便于修改。eg: 当我们要修改Nginx的html内容时，需要进入容器内部修改，很不方便。</li><li>数据不可服用。在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。</li><li>升级维护困难。 数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li></ul><p><strong>数据卷</strong>：是一个虚拟目录指向宿主机文件系统中的某个目录（真实目录）。</p><p><img src="/img/blogImg/dockerVolume.png" alt="数据卷"></p><h2 id="3-2-操作数据卷"><a href="#3-2-操作数据卷" class="headerlink" title="3.2 操作数据卷"></a>3.2 操作数据卷</h2><p>数据卷操作的基本语法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><p>​    <code>create</code> 创建一个volume</p><p>​    <code>inspect</code> 显示一个或多个volume的信息</p><p>​    <code>ls</code> 列出所有的volume</p><p>​    <code>prune</code> 删除未使用的volume</p><p>​    <code>rm</code> 删除一个或多个指定的volume</p><blockquote><p>windows中创建的数据卷的地址为(点击<a href="file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/">这里</a>查看)：</p><p>file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/</p></blockquote><h2 id="3-3-挂载数据卷"><a href="#3-3-挂载数据卷" class="headerlink" title="3.3 挂载数据卷"></a>3.3 挂载数据卷</h2><p>创建容器时，可以通过 <code>-v</code> 参数来挂在一个数据卷到某个容器目录。</p><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mynginx -p 8080:8080 -v html:/root/html  -d nginx <br><span class="hljs-meta">#</span><span class="bash">-v html:/root/html 把html数据卷挂载到容器内的/root/html这个目录中</span><br></code></pre></td></tr></table></figure><h3 id="3-3-1-案例-数据卷挂载-："><a href="#3-3-1-案例-数据卷挂载-：" class="headerlink" title="3.3.1 案例(数据卷挂载)："></a>3.3.1 案例(数据卷挂载)：</h3><p>​    创建nginx容器，修改容器内的html目录内的index.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume create html  #创建html数据卷<br>docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br><span class="hljs-meta">#</span><span class="bash"> 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-meta">#</span><span class="bash"> 进入该目录（Linux）</span><br>cd /var/lib/docker/volumes/html/_data<br><span class="hljs-meta">#</span><span class="bash"> 修改文件（Linux）</span><br>vi index.html<br></code></pre></td></tr></table></figure><blockquote><p>windows中关联数据卷，进入</p><p>file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/html/_data目录下，修改index.html</p></blockquote><h3 id="3-3-2-案例-宿主机目录挂载"><a href="#3-3-2-案例-宿主机目录挂载" class="headerlink" title="3.3.2 案例(宿主机目录挂载)"></a>3.3.2 案例(宿主机目录挂载)</h3><p>windows：</p><ul><li>路径盘符要小写</li><li>文件夹名称不能有空格</li><li>文件最好提前创建，不然自动创建出来的是个文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name myNginx -p 80:80 -d -v d:\AppData\docker\volumes\html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure><blockquote><p>​    在计算机的<code>d:\AppData\docker\volumes\html</code>目录下，新增或变更资源，都会同步到nginx的<code>/usr/share/nginx/html</code>目录中</p></blockquote><p>目录挂载与数据卷挂载的语法是类似的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v [宿主机目录]:[容器内目录]<br>-v [宿主机文件]:[容器内文件]<br></code></pre></td></tr></table></figure><h3 id="3-3-3-数据卷挂载与目录直接挂载的区别"><a href="#3-3-3-数据卷挂载与目录直接挂载的区别" class="headerlink" title="3.3.3 数据卷挂载与目录直接挂载的区别"></a>3.3.3 数据卷挂载与目录直接挂载的区别</h3><p>数据卷挂载：(自动化但隐藏细节) 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</p><p>目录挂载: (细节自己实现，没有自动化) 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</p><h1 id="4、Dockerfile自定义镜像"><a href="#4、Dockerfile自定义镜像" class="headerlink" title="4、Dockerfile自定义镜像"></a>4、Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="4-1-镜像结构"><a href="#4-1-镜像结构" class="headerlink" title="4.1 镜像结构"></a>4.1 镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><blockquote><p>底层函数库 -》 环境配置 -》依赖安装 -》应用安装 -》应用配置</p></blockquote><p><img src="/img/blogImg/imageStruct.png" alt="模拟Mysql镜像结构"></p><p>镜像是分层结构，每一层称为一个Layer</p><p>简单来说，镜像就是在系统函数库、运行环境<strong>基础</strong>上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="4-2-Dockerfile语法"><a href="#4-2-Dockerfile语法" class="headerlink" title="4.2 Dockerfile语法"></a>4.2 Dockerfile语法</h2><h3 id="4-2-1-什么是Dockerfile"><a href="#4-2-1-什么是Dockerfile" class="headerlink" title="4.2.1 什么是Dockerfile"></a>4.2.1 什么是Dockerfile</h3><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">指定基础镜像</td><td align="center">FROM centos:6</td></tr><tr><td align="center">ENV</td><td align="center">设置环境变量，可在后面指令使用</td><td align="center">ENV key value</td></tr><tr><td align="center">COPY</td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center">COPY ./mysql-5.7.rpm /tmp</td></tr><tr><td align="center">RUN</td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center">RUN yum install gcc</td></tr><tr><td align="center">EXPOSE</td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>更新详细语法说明，请参考<a href="https://docs.docker.com/engine/reference/builder">官网文档</a></p><h2 id="4-3-构建Java项目"><a href="#4-3-构建Java项目" class="headerlink" title="4.3 构建Java项目"></a>4.3 构建Java项目</h2><h3 id="4-3-1-基于Ubuntu构建Java项目"><a href="#4-3-1-基于Ubuntu构建Java项目" class="headerlink" title="4.3.1 基于Ubuntu构建Java项目"></a>4.3.1 基于Ubuntu构建Java项目</h3><p>​    需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p></li><li><p>步骤2：拷贝docker-demo.jar文件到docker-demo这个目录</p></li><li><p>步骤3：拷贝jdk8.tar.gz文件到docker-demo这个目录</p></li><li><p>步骤4：拷贝Dockerfile到docker-demo这个目录</p></li></ul><p>Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span><br><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure><ul><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><p>构建镜像</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t javaweb:1.0 .<br></code></pre></td></tr></table></figure><h3 id="4-3-2-基于java8构建Java项目"><a href="#4-3-2-基于java8构建Java项目" class="headerlink" title="4.3.2 基于java8构建Java项目"></a>4.3.2 基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs doc">FROM java:8-alpine<br>COPY ./app.jar /tmp/app.jar<br>EXPOSE 8090<br>ENTRYPOINT java -jar /tmp/app.jar<br></code></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h3 id="4-3-3-小结"><a href="#4-3-3-小结" class="headerlink" title="4.3.3 小结"></a>4.3.3 小结</h3><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="5、DockerCompose"><a href="#5、DockerCompose" class="headerlink" title="5、DockerCompose"></a>5、DockerCompose</h1><p>Docker Compose可以基于<strong>Compose文件</strong>帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><h2 id="5-1-初始DockerCompose"><a href="#5-1-初始DockerCompose" class="headerlink" title="5.1 初始DockerCompose"></a>5.1 初始DockerCompose</h2><p>Compose文件是一个<strong>文本文件</strong>，通过<strong>指令</strong>定义集群中的每个容器如何运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> <span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-string">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">environment:</span><br>     <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span> <br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-string">-</span> <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     <span class="hljs-string">-</span> <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-string">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8090:8090&quot;</span><br></code></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考<a href="https://docs.docker.com/compose/compose-file/">官网</a></p><p>其实DockerCompose文件可以看做是将多个<code>docker run</code>命令写到一个文件，只是语法稍有差异。</p><h2 id="5-2-安装DockerCompose"><a href="#5-2-安装DockerCompose" class="headerlink" title="5.2 安装DockerCompose"></a>5.2 安装DockerCompose</h2><p>参考<a href="https://cherishll-git.github.io/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/">docker的介绍与安装</a></p><h2 id="5-3-部署微服务集群"><a href="#5-3-部署微服务集群" class="headerlink" title="5.3 部署微服务集群"></a>5.3 部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h1 id="6、Docker镜像仓库"><a href="#6、Docker镜像仓库" class="headerlink" title="6、Docker镜像仓库"></a>6、Docker镜像仓库</h1><h2 id="6-1搭建私有镜像仓库"><a href="#6-1搭建私有镜像仓库" class="headerlink" title="6.1搭建私有镜像仓库"></a>6.1搭建私有镜像仓库</h2><p>参考<a href="https://cherishll-git.github.io/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/">docker的介绍与安装</a></p><h2 id="6-2-推送、拉取镜像"><a href="#6-2-推送、拉取镜像" class="headerlink" title="6.2 推送、拉取镜像"></a>6.2 推送、拉取镜像</h2><p>推送镜像到<strong>私有镜像</strong>服务<strong>必须先tag</strong>，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的安装</title>
    <link href="/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <url>/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Docker基本概念"><a href="#1、Docker基本概念" class="headerlink" title="1、Docker基本概念"></a>1、Docker基本概念</h1><h2 id="1-1-Docker初识"><a href="#1-1-Docker初识" class="headerlink" title="1.1 Docker初识"></a>1.1 Docker初识</h2><p>​    Docker是一个开源的应用容器框架</p><p>​    基于Go语言实现</p><p>​    Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。</p><p>​    容器完全使用<strong>沙箱机制</strong>，相互隔离</p><p>​    容器性能开销极低</p><p>​    <strong>小结：docker是一个容器技术，解决软件跨环境迁移的问题</strong></p><h2 id="1-2-Docker解决兼容性问题"><a href="#1-2-Docker解决兼容性问题" class="headerlink" title="1.2 Docker解决兼容性问题"></a>1.2 Docker解决兼容性问题</h2><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p>为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3 Docker架构"></a>1.3 Docker架构</h2><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。一个镜像可以运行多个容器</p><p>是一个C/S架构的程序，有两部分组成：</p><ul><li>服务端：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>客户端：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><p>Docker的工作流：</p><ul><li><p>构建自定义镜像或者从DockerRegistry拉取镜像</p></li><li><p>根据镜像创建容器，并运行</p></li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4 安装Docker"></a>1.4 安装Docker</h2><h3 id="1-4-1-安装Windows版"><a href="#1-4-1-安装Windows版" class="headerlink" title="1.4.1 安装Windows版"></a>1.4.1 安装Windows版</h3><pre><code>此处参考[博客](https://www.cnblogs.com/wangyang0210/p/13212610.html)</code></pre><h3 id="1-4-2-Linux版-CentOS-7-为例"><a href="#1-4-2-Linux版-CentOS-7-为例" class="headerlink" title="1.4.2 Linux版(CentOS 7 为例)"></a>1.4.2 Linux版(CentOS 7 为例)</h3><p>Docker 分为CE和EE两大版本。</p><p>Linux版：Docker CE支持64位版本CentOS 7，并且要求内核版本不低于3.10，CentOS 7 满足最低内核要求。</p><h4 id="1-4-2-1-卸载（可选）"><a href="#1-4-2-1-卸载（可选）" class="headerlink" title="1.4.2.1 卸载（可选）"></a>1.4.2.1 卸载（可选）</h4><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#反斜杠的作用是连接作用</span></span><br>yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine \<br>                  docker-ce<br></code></pre></td></tr></table></figure><h4 id="1-4-2-2-安装yum工具"><a href="#1-4-2-2-安装yum工具" class="headerlink" title="1.4.2.2 安装yum工具"></a>1.4.2.2 安装yum工具</h4><p>首先需要虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils \<br>           device-mapper-persistent-data \<br>           lvm2 --skip-broken<br></code></pre></td></tr></table></figure><p>更新XFS文件系统管理工具及本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update xfsprogs -y<br></code></pre></td></tr></table></figure><p>然后更新本地镜像源:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#设置docker镜像源</span></span><br>yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>    <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#解决域名问题</span></span><br>sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><h4 id="1-4-2-3-安装docker（ce版本）"><a href="#1-4-2-3-安装docker（ce版本）" class="headerlink" title="1.4.2.3 安装docker（ce版本）"></a>1.4.2.3 安装docker（ce版本）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y docker-ce  ##-y 安装过程中不用询问，问就是yes<br></code></pre></td></tr></table></figure><h4 id="1-4-2-4-启动docker"><a href="#1-4-2-4-启动docker" class="headerlink" title="1.4.2.4 启动docker"></a>1.4.2.4 启动docker</h4><p>Docker应用需要用到各种端口，逐一去修改防火墙设置，会非常麻烦，建议<strong>关闭防火墙</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 关闭</span><br>systemctl stop firewalld<br><span class="hljs-meta">#</span><span class="bash"> 禁止开机启动防火墙</span><br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><p>通过命令启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#启动后查看docker版本</span></span><br>docker --version<br></code></pre></td></tr></table></figure><h4 id="1-4-2-5-配置docker镜像"><a href="#1-4-2-5-配置docker镜像" class="headerlink" title="1.4.2.5 配置docker镜像"></a>1.4.2.5 配置docker镜像</h4><p>docker官方镜像仓库网速较差，我们需要设置国内镜像：</p><p>参考阿里云的<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">镜像加速文档</a></p><h3 id="1-4-3-win10-安装docker-desktop"><a href="#1-4-3-win10-安装docker-desktop" class="headerlink" title="1.4.3 win10 安装docker desktop"></a>1.4.3 win10 安装docker desktop</h3><p>参考<a href="https://www.cnblogs.com/wangyang0210/p/13212610.html">博客</a></p><h1 id="2、安装DockerCompose"><a href="#2、安装DockerCompose" class="headerlink" title="2、安装DockerCompose"></a>2、安装DockerCompose</h1><h2 id="2-1-Linux版本"><a href="#2-1-Linux版本" class="headerlink" title="2.1 Linux版本"></a>2.1 Linux版本</h2><h3 id="2-1-1-下载"><a href="#2-1-1-下载" class="headerlink" title="2.1.1 下载"></a>2.1.1 下载</h3><p>Linux下需要通过命令下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装</span><br>curl -L https://github.com/docker/compose/releases/download/1.29.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="2-1-2-修改文件权限"><a href="#2-1-2-修改文件权限" class="headerlink" title="2.1.2 修改文件权限"></a>2.1.2 修改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改权限</span><br>chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="2-1-3-Base自动补全命令"><a href="#2-1-3-Base自动补全命令" class="headerlink" title="2.1.3 Base自动补全命令"></a>2.1.3 Base自动补全命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 补全命令</span><br>curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose<br></code></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="2-2-Window安装"><a href="#2-2-Window安装" class="headerlink" title="2.2 Window安装"></a>2.2 Window安装</h2><h3 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h3><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><h3 id="2-2-2-安装"><a href="#2-2-2-安装" class="headerlink" title="2.2.2 安装"></a>2.2.2 安装</h3><p>双击下载的安装包直接安装</p><h1 id="3、Docker镜像仓库"><a href="#3、Docker镜像仓库" class="headerlink" title="3、Docker镜像仓库"></a>3、Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1 简化版镜像仓库"></a>3.1 简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --restart=always \<br>    --name registry\<br>    -p 5000:5000 \<br>    -v registry-data:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2 带有图形化界面版本"></a>3.2 带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry</p><p>docker-compose.yml文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./registry-data:/var/lib/registry</span><br>  <span class="hljs-attr">ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">joxit/docker-registry-ui:static</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_TITLE=私有仓库</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_URL=http://registry:5000</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br></code></pre></td></tr></table></figure><p>执行命令构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3 配置Docker信任地址"></a>3.3 配置Docker信任地址</h2><p>我们的私服采用的http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#打开要修改的文件</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment">#添加内容</span><br><span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;http://192.168.150.101:8080&quot;</span>]<br><span class="hljs-comment">#重加载</span><br>systemctl daemon-reload<br><span class="hljs-comment">#重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json字符串与对象的互转</title>
    <link href="/2021/12/03/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E8%BD%AC/"/>
    <url>/2021/12/03/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>在开发过程中，经常需要和别的系统交换数据，数据交换的格式有XML、JSON等，JSON作为一个轻量级的数据格式比xml效率要高，XML需要很多的标签，这无疑占据了网络流量，JSON在这方面则做的很好，下面先看下JSON的格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;JSON&quot;</span>,<span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京市西城区&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">25</span>&#125;<span class="hljs-comment">//JSON的对象格式的字符串</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;com.lyq.pojo.Student&quot;</span>,&#123;<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;211&quot;</span>,<span class="hljs-attr">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-attr">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-attr">&quot;db&quot;</span>:<span class="hljs-string">&quot;mysql&quot;</span>&#125;]<span class="hljs-comment">//数组对象格式</span><br></code></pre></td></tr></table></figure><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>​    要实现JSON与java对象之间的互转，需要借助<strong>第三方jar包</strong>，此处使用json-lib这个jar包，可以冲<a href="https://mvnrepository.com/">此处</a>下载相关jar包，json-lib需要<code>commons-beanutils-1.8.0.jar、commons-collections-3.2.1.jar、commons-lang-2.5.jar、commons-logging-1.1.1.jar、ezmorph-1.0.6.jar </code>五个包的支持。</p><p>json-lib提供了几个类可以完成此功能，例<code>JSONObject、JSONArray</code>从类的名字上可以看出JSONObject转化的应该是对象格式的，而JSONArray转化的则应该是数组对象（即，带[]形式）的。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>jdk15<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ezmorph<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ezmorph<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、Java普通对象和JSON字符串的互转"><a href="#2、Java普通对象和JSON字符串的互转" class="headerlink" title="2、Java普通对象和JSON字符串的互转"></a>2、Java普通对象和JSON字符串的互转</h2><h3 id="2-1-Java对象-–》Json字符串"><a href="#2-1-Java对象-–》Json字符串" class="headerlink" title="2.1 Java对象 –》Json字符串"></a>2.1 Java对象 –》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String stuno;<br>    <span class="hljs-keyword">private</span> String stuname;<br>    <span class="hljs-keyword">private</span> String stusex;<br>    <span class="hljs-keyword">private</span> String db;<br>    <br>    <span class="hljs-comment">//此处省略setter和getter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    Java对象转Json字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Student对象通过JSONObject和JSONArray两种方式转Json字符串</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertObject</span><span class="hljs-params">()</span> </span>&#123;        <br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;成武&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        JSONObject json = JSONObject.fromObject(stu);<br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray array=JSONArray.fromObject(stu);<br>        <br>        String strJson=json.toString();<br>        String strArray=array.toString();<br>        <br>        System.out.println(<span class="hljs-string">&quot;strJson:&quot;</span>+strJson);<br>        System.out.println(<span class="hljs-string">&quot;strArray:&quot;</span>+strArray);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面为打印结果：</p><blockquote><p>strJson:{“db”:”Mysql”,”id”:3,”stuname”:”成武”,”stuno”:”100”,”stusex”:”M”}<br>strArray:[{“db”:”Mysql”,”id”:3,”stuname”:”成武”,”stuno”:”100”,”stusex”:”M”}]</p></blockquote><p>​    两种方法都可以把java对象转化为JSON字符串，只是转化后的<strong>结构</strong>不同。</p><h3 id="2-2-JSON字符串-—》Java对象"><a href="#2-2-JSON字符串-—》Java对象" class="headerlink" title="2.2 JSON字符串 —》Java对象"></a>2.2 JSON字符串 —》Java对象</h3><p>​    首先需要定义两种不同格式的字符串，需要使用\对双引号进行转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonStrToJava</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//定义两种不同格式的字符串</span><br>        String objectStr=<span class="hljs-string">&quot;&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;李四\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;&quot;</span>;<br>        String arrayStr=<span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;李四\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;]&quot;</span>;<br>    <br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        JSONObject jsonObject=JSONObject.fromObject(objectStr);<br>        Student stu=(Student)JSONObject.toBean(jsonObject, Student.class);<br>        <br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray jsonArray=JSONArray.fromObject(arrayStr);<br>        <span class="hljs-comment">//获得jsonArray的第一个元素</span><br>        Object o=jsonArray.get(<span class="hljs-number">0</span>);<br>        JSONObject jsonObject2=JSONObject.fromObject(o);<br>        Student stu2=(Student)JSONObject.toBean(jsonObject2, Student.class);<br>        System.out.println(<span class="hljs-string">&quot;stu:&quot;</span>+stu);<br>        System.out.println(<span class="hljs-string">&quot;stu2:&quot;</span>+stu2);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面为打印结果：</p><blockquote><p>stu:Student{id=3, stuno=’100’, stuname=’李四’, stusex=’M’, db=’Mysql’}<br>stu2:Student{id=3, stuno=’100’, stuname=’李四’, stusex=’M’, db=’Mysql’}</p></blockquote><p>​    使用<code>JSONObject</code>可以轻松的把JSON格式的字符串转化为java对象，但是使用<code>JSONArray</code>就没那么容易了，因为它有<strong>“[]”</strong>符号，所以我们这里在<strong>获得了JSONArray的对象之后</strong>，<strong>取其第一个元素</strong>即我们需要的一个student的变形，然后使用JSONObject轻松获得</p><h2 id="3、list和json字符串的互转"><a href="#3、list和json字符串的互转" class="headerlink" title="3、list和json字符串的互转"></a>3、<strong>list和json字符串的互转</strong></h2><h3 id="3-1-list-–》Json字符串"><a href="#3-1-list-–》Json字符串" class="headerlink" title="3.1 list –》Json字符串"></a>3.1 list –》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listToJSON</span><span class="hljs-params">()</span></span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;王建&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br>        Student stu2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;102&quot;</span>, <span class="hljs-string">&quot;李承&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        List&lt;Student&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>        lists.add(stu);<br>        lists.add(stu2);<br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        <span class="hljs-comment">//JSONObject listObject=JSONObject.fromObject(lists);//会报错</span><br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray listArray=JSONArray.fromObject(lists);<br><br>        <span class="hljs-comment">//System.out.println(&quot;listObject:&quot;+listObject.toString());</span><br>        System.out.println(<span class="hljs-string">&quot;listArray:&quot;</span>+listArray.toString());<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>​    我把使用JSONObject的方式给注掉了，我们先看注释之前的结果：</p><blockquote><p>net.sf.json.JSONException: ‘object’ is an array. Use JSONArray instead</p></blockquote><p>​    注释后，正确执行结果为：</p><blockquote><p>listArray:[{“db”:”Mysql”,”id”:4,”stuname”:”王建”,”stuno”:”101”,”stusex”:”M”},{“db”:”Mysql”,”id”:5,”stuname”:”李承”,”stuno”:”102”,”stusex”:”N”}]</p></blockquote><h3 id="3-2-Json字符串-–》list"><a href="#3-2-Json字符串-–》list" class="headerlink" title="3.2 Json字符串 –》list"></a>3.2 Json字符串 –》list</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonToList</span><span class="hljs-params">()</span></span>&#123;<br>        String arrayStr=<span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:\&quot;4\&quot;,\&quot;stuname\&quot;:\&quot;王建\&quot;,\&quot;stuno\&quot;:\&quot;101\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;]&quot;</span>;<br>        <span class="hljs-comment">//转化为list</span><br>        List&lt;Student&gt; list2=(List&lt;Student&gt;)JSONArray.toList(JSONArray.fromObject(arrayStr), Student.class);<br><br>        <span class="hljs-keyword">for</span> (Student stu : list2) &#123;<br>            System.out.println(stu);<br>        &#125;<br>        <span class="hljs-comment">//转化为数组</span><br>        Student[] ss =(Student[])JSONArray.toArray(JSONArray.fromObject(arrayStr),Student.class);<br>        <span class="hljs-keyword">for</span> (Student student : ss) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;王建&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br>Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;王建&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>由于字符串的格式为带有“[]”的格式，所以这里<strong>选择JSONArray</strong>这个对象，它有<code>toArray、toList</code>方法可供使用，前者转化为java中的<strong>数组</strong>，后者转化为java中的<strong>list</strong>，由于这里有实体类进行对应，所以在使用时指定了泛型的类型（Student.class），这样就可以得到转化后的对象</p><h2 id="4、map和Json字符串的互转"><a href="#4、map和Json字符串的互转" class="headerlink" title="4、map和Json字符串的互转"></a>4、map和Json字符串的互转</h2><h3 id="4-1-Map-—》Json字符串"><a href="#4-1-Map-—》Json字符串" class="headerlink" title="4.1 Map —》Json字符串"></a>4.1 Map —》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mapToJSON</span><span class="hljs-params">()</span></span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;成武&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br>        Student stu1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;王建&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        HashMap&lt;String, Student&gt; stuMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Student&gt;();<br>        stuMap.put(<span class="hljs-string">&quot;first&quot;</span>,stu);<br>        stuMap.put(<span class="hljs-string">&quot;second&quot;</span>,stu1);<br><br>        <span class="hljs-comment">//1、JSONObject</span><br>        JSONObject mapObject= JSONObject.fromObject(stuMap);<br>        System.out.println(<span class="hljs-string">&quot;mapObject&quot;</span>+mapObject.toString());<br><br>        <span class="hljs-comment">//2、JSONArray</span><br>        JSONArray mapArray=JSONArray.fromObject(stuMap);<br>        System.out.println(<span class="hljs-string">&quot;mapArray:&quot;</span>+mapArray.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mapObject</span>&#123;<span class="hljs-string">&quot;first&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;成武&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;100&quot;</span>&#125;,<span class="hljs-string">&quot;second&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;王建&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;101&quot;</span>&#125;&#125;<br><span class="hljs-attribute">mapArray</span>:[&#123;<span class="hljs-string">&quot;first&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;成武&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;100&quot;</span>&#125;,<span class="hljs-string">&quot;second&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;王建&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;101&quot;</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><h3 id="4-2-Json字符串-—》Map"><a href="#4-2-Json字符串-—》Map" class="headerlink" title="4.2 Json字符串 —》Map"></a>4.2 Json字符串 —》Map</h3><p>JSON字符串不能直接转化为map对象，要想取得map中的键对应的值需要别的方式，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Student first;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(Student first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonToMap</span><span class="hljs-params">()</span></span>&#123;<br>        String strObject=<span class="hljs-string">&quot;&#123;\&quot;first\&quot;:&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;成武\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;&#125;&quot;</span>;<br><br>        <span class="hljs-comment">//JSONObject</span><br>        JSONObject jsonObject=JSONObject.fromObject(strObject);<br>        Map map=<span class="hljs-keyword">new</span> HashMap();<br>        map.put(<span class="hljs-string">&quot;first&quot;</span>, Student.class);<br><br>        <span class="hljs-comment">//使用了toBean方法，需要三个参数</span><br>        MyBean my=(MyBean)JSONObject.toBean(jsonObject, MyBean.class, map);<br>        System.out.println(my.getFirst());<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;成武&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>使用toBean()方法是传入了三个参数，第一个是JSONObject对象，第二个是MyBean.class，第三个是一个Map对象。通过MyBean可以知道此类中要有一个first的属性，且其类型为Student，要和map中的键和值类型对应，即，first对应键 first类型对应值的类型。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown的基本使用</title>
    <link href="/2021/12/01/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/01/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Markdown标题"><a href="#1、Markdown标题" class="headerlink" title="1、Markdown标题"></a>1、Markdown标题</h1><h2 id="1-1-使用-和-标记一级和二级标题"><a href="#1-1-使用-和-标记一级和二级标题" class="headerlink" title="1.1 使用 = 和 - 标记一级和二级标题"></a>1.1 使用 = 和 - 标记一级和二级标题</h2><p>= 和 - 标记语法格式如下:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我展示的是一级标题</span><br><span class="hljs-section">=================</span><br><br><span class="hljs-section">我展示的是二级标题</span><br><span class="hljs-section">-----------------</span><br></code></pre></td></tr></table></figure><h2 id="1-2-使用-号标记"><a href="#1-2-使用-号标记" class="headerlink" title="1.2 使用#号标记"></a>1.2 使用#号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><h1 id="2、段落格式"><a href="#2、段落格式" class="headerlink" title="2、段落格式"></a>2、段落格式</h1><h2 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2.1 字体"></a>2.1 字体</h2><p>markdown可以使用一下几种字体</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><h2 id="2-2-分割线"><a href="#2-2-分割线" class="headerlink" title="2.2 分割线"></a>2.2 分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span> <span class="hljs-emphasis">* *</span></span><br><span class="hljs-strong"></span><br><span class="hljs-strong">**</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">- - -</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">----------</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~BAIDU.COM~~<br></code></pre></td></tr></table></figure><p>效果如：<del>BAIDU.COM</del></p><h2 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h2><p>下划线可以通过 HTML 的 <code>^&lt;u&gt;</code> 标签来实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果为： <u>带下划线文本</u></p><h2 id="2-5-注脚"><a href="#2-5-注脚" class="headerlink" title="2.5 注脚"></a>2.5 注脚</h2><p>脚注是对文本的补充说明。Markdown 脚注的格式如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[^要注明的文本]<br></code></pre></td></tr></table></figure><h1 id="3、Markdown-列表"><a href="#3、Markdown-列表" class="headerlink" title="3、Markdown 列表"></a>3、Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p><h2 id="3-1无序列表"><a href="#3-1无序列表" class="headerlink" title="3.1无序列表"></a>3.1无序列表</h2><p>  使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要<strong>添加一个空格</strong>，然后再填写内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><h2 id="3-2有序列表"><a href="#3-2有序列表" class="headerlink" title="3.2有序列表"></a>3.2有序列表</h2><p>  使用数字并加上 . 号来表示，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><h2 id="3-3-列表嵌套"><a href="#3-3-列表嵌套" class="headerlink" title="3.3 列表嵌套"></a>3.3 列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项：<br><span class="hljs-bullet">    -</span> 第一项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第一项嵌套的第二个元素<br><span class="hljs-bullet">2.</span> 第二项：<br><span class="hljs-bullet">    -</span> 第二项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第二项嵌套的第二个元素<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="4、Markdown区块"><a href="#4、Markdown区块" class="headerlink" title="4、Markdown区块"></a>4、Markdown区块</h1><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">区块引用</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">菜鸟教程</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">学的不仅是技术更是梦想</span><br></code></pre></td></tr></table></figure><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">最外层</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; 第一层嵌套</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure><p>展示效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="4-1-区块中使用列表"><a href="#4-1-区块中使用列表" class="headerlink" title="4.1 区块中使用列表"></a>4.1 区块中使用列表</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">区块中使用列表</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第一项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第二项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><p>显示结果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><h2 id="4-2-列表中使用区块"><a href="#4-2-列表中使用区块" class="headerlink" title="4.2 列表中使用区块"></a>4.2 列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前<strong>添加四个空格</strong>的缩进。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>第一项<br><span class="hljs-code">    &gt; 菜鸟教程</span><br><span class="hljs-code">    &gt; 学的不仅是技术更是梦想</span><br><span class="hljs-bullet">* </span>第二项<br></code></pre></td></tr></table></figure><p>显示效果如下</p><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h1 id="5、Markdown代码"><a href="#5、Markdown代码" class="headerlink" title="5、Markdown代码"></a>5、Markdown代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`printf()` 函数<br></code></pre></td></tr></table></figure><p>显示效果为： <code>printf()</code> 函数</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>也可以使用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><h1 id="6、Markdown-链接"><a href="#6、Markdown-链接" class="headerlink" title="6、Markdown 链接"></a>6、Markdown 链接</h1><h2 id="6-1-使用方法："><a href="#6-1-使用方法：" class="headerlink" title="6.1 使用方法："></a>6.1 使用方法：</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[链接名称]</span>(链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：<code>这是一个链接 [菜鸟教程](https://www.runoob.com)</code><br>效果为：这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>直接使用链接地址： <code>&lt;https://www.runoob.com&gt;</code><br>效果为：<a href="https://www.runoob.com/">https://www.runoob.com</a></p><h2 id="6-2-高级链接"><a href="#6-2-高级链接" class="headerlink" title="6.2 高级链接"></a>6.2 高级链接</h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less">这个链接用 <span class="hljs-selector-tag">1</span> 作为网址变量 <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[1]</span><br>这个链接用 <span class="hljs-selector-tag">runoob</span> 作为网址变量 <span class="hljs-selector-attr">[Runoob]</span><span class="hljs-selector-attr">[runoob]</span><br>然后在文档的结尾为变量赋值（网址）<br><br>  <span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.google.com/</span><br>  <span class="hljs-selector-attr">[runoob]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.runoob.com/</span><br></code></pre></td></tr></table></figure><p>效果为：<br>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="7、Markdown-图片"><a href="#7、Markdown-图片" class="headerlink" title="7、Markdown 图片"></a>7、Markdown 图片</h1><p>Markdown 图片语法格式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址)<br><br>!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址 <span class="hljs-string">&quot;可选标题&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>使用实例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p>显示效果为:<br><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">这个链接用 <span class="hljs-number">1</span> 作为网址变量 [RUNOOB][<span class="hljs-number">1</span>].<br>然后在文档的结尾为变量赋值（网址）<br><br>[<span class="hljs-number">1</span>]: http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png<br></code></pre></td></tr></table></figure><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="8、Markdown-表格"><a href="#8、Markdown-表格" class="headerlink" title="8、Markdown 表格"></a>8、Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行<br>语法格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><p>显示的效果为：<br>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br>对齐方式<br>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。、<br>实例如下：<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure>显示效果为为：<table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/27/hello-world/"/>
    <url>/2021/11/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! 这是hexo自动生成的第一个欢迎也面. 查看 <a href="https://hexo.io/docs/">文档</a> 了解更多信息. 如果您在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">疑难解答</a>中找到答案 ,也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>上询问我.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建一个新的也面"><a href="#创建一个新的也面" class="headerlink" title="创建一个新的也面"></a>创建一个新的也面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动blog服务"><a href="#启动blog服务" class="headerlink" title="启动blog服务"></a>启动blog服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到远端"><a href="#发布到远端" class="headerlink" title="发布到远端"></a>发布到远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
