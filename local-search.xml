<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初识MQ</title>
    <link href="/2021/12/07/%E5%88%9D%E8%AF%86MQ/"/>
    <url>/2021/12/07/%E5%88%9D%E8%AF%86MQ/</url>
    
    <content type="html"><![CDATA[<h1 id="1、同步通讯"><a href="#1、同步通讯" class="headerlink" title="1、同步通讯"></a>1、同步通讯</h1><p>​    <strong>同步与异步通讯</strong>：</p><p>​        微服务间通讯有同步和异步两种方式：</p><p>​        同步通讯：就像打电话，需要实时响应。</p><p>​        异步通讯：就像发邮件，不需要马上回复。</p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><p><strong>Feign调用</strong>就属于<strong>同步方式</strong>，虽然调用可以实时得到结果，但<strong>存在</strong>下面的<strong>问题</strong>：</p><ul><li>耦合度高。每次加入新的需求，都要修改原来的代码</li><li>性能下降。调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用时间的总和</li><li>浪费资源。调用链中的每个服务都在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li><li>级联失败。如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li></ul><p>同步调用的<strong>优点</strong>：</p><ul><li>时效性较强，可以立即得到结果</li></ul><h1 id="2、异步通讯"><a href="#2、异步通讯" class="headerlink" title="2、异步通讯"></a>2、异步通讯</h1><p>异步调用常见实现就是事件驱动模式。可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="D:\git-data\CherishLLBlog\source\img\blogImg\broker.png" alt="事件驱动"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>事件驱动的优势：</p><ul><li>服务解耦。每个服务都可以灵活插拔，可替换</li><li>性能提升，吞吐量提高。无需等待订阅者处理完成，响应更快速</li><li>服务没有强依赖，不用担心级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>流量削峰。不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h1 id="4、MQ常用框架"><a href="#4、MQ常用框架" class="headerlink" title="4、MQ常用框架"></a>4、MQ常用框架</h1><p>MQ（messageQueue），消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的基本使用</title>
    <link href="/2021/12/06/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/06/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1、镜像操作"><a href="#1、镜像操作" class="headerlink" title="1、镜像操作"></a>1、镜像操作</h1><h2 id="1-1-镜像的相关命令"><a href="#1-1-镜像的相关命令" class="headerlink" title="1.1 镜像的相关命令"></a>1.1 镜像的相关命令</h2><p>​    镜像名称：一般分为两部分  [repository]:[tag]   【在没有指定tag时，默认是latest，代表最新版本的镜像】</p><p><img src="D:\git-data\CherishLLBlog\source\img\blogImg\dockerImage.png" alt="镜像"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images      #查看镜像<br>docker rmi#删除镜像<br>docker pull#从服务拉取镜像<br>docker push#推送镜像到服务<br>docker save #保存镜像为压缩包<br>docker load#加载压缩包为镜像<br>docker build       #基于Dockerfile构建镜像<br></code></pre></td></tr></table></figure><h1 id="2、Docker的容器操作"><a href="#2、Docker的容器操作" class="headerlink" title="2、Docker的容器操作"></a>2、Docker的容器操作</h1><p><img src="D:\git-data\CherishLLBlog\source\img\blogImg\dockerContiner.png" alt="容器操作"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.6#运行一个容器<br>--name #指定容器名称<br>  -p #指定端口映射<br>  -d 让容器后台运行<br>docker logs #查看容器日志命令，添加-f参数可以持续查看日志<br>docker ps #查看容器状态。添加-a参数查看所有状态的容器<br>docker exec -it [容器名] [要执行的命令] #进入容器执行<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">exec</span>命令可以进入容器修改文件，但是在容器内修改文件是不推荐的</span><br><span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it mn bash <span class="hljs-comment">## 其中bash是一个linux终端交互命令</span></span><br>docker rm  #不能删除运行中的容器，除非添加 -f 参数<br></code></pre></td></tr></table></figure><h2 id="2-1-运行redis容器"><a href="#2-1-运行redis容器" class="headerlink" title="2.1 运行redis容器"></a>2.1 运行redis容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 6379:6379 -v $PWD/data:/data  -d redis:3.2 redis-server --appendonly yes<br><span class="hljs-meta">#</span><span class="bash">-v <span class="hljs-variable">$PWD</span>/data:/data : 将主机中当前目录下的data挂载到容器的/data</span><br><span class="hljs-meta">#</span><span class="bash">redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-简单操作"><a href="#2-1-2-简单操作" class="headerlink" title="2.1.2 简单操作"></a>2.1.2 简单操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it redis bash  #进入redis容器<br>redis-cli#执行redis-cli客户端命令<br></code></pre></td></tr></table></figure><h1 id="3、Docker数据卷"><a href="#3、Docker数据卷" class="headerlink" title="3、Docker数据卷"></a>3、Docker数据卷</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>容器与数据耦合的问题：</p><ul><li>不便于修改。eg: 当我们要修改Nginx的html内容时，需要进入容器内部修改，很不方便。</li><li>数据不可服用。在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。</li><li>升级维护困难。 数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li></ul><p><strong>数据卷</strong>：是一个虚拟目录指向宿主机文件系统中的某个目录（真实目录）。</p><p><img src="D:\git-data\CherishLLBlog\source\img\blogImg\dockerVolume.png" alt="数据卷"></p><h2 id="3-2-操作数据卷"><a href="#3-2-操作数据卷" class="headerlink" title="3.2 操作数据卷"></a>3.2 操作数据卷</h2><p>数据卷操作的基本语法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><p>​    <code>create</code> 创建一个volume</p><p>​    <code>inspect</code> 显示一个或多个volume的信息</p><p>​    <code>ls</code> 列出所有的volume</p><p>​    <code>prune</code> 删除未使用的volume</p><p>​    <code>rm</code> 删除一个或多个指定的volume</p><blockquote><p>windows中创建的数据卷的地址为(点击<a href="file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/">这里</a>查看)：</p><p>file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/</p></blockquote><h2 id="3-3-挂载数据卷"><a href="#3-3-挂载数据卷" class="headerlink" title="3.3 挂载数据卷"></a>3.3 挂载数据卷</h2><p>创建容器时，可以通过 <code>-v</code> 参数来挂在一个数据卷到某个容器目录。</p><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mynginx -p 8080:8080 -v html:/root/html  -d nginx <br><span class="hljs-meta">#</span><span class="bash">-v html:/root/html 把html数据卷挂载到容器内的/root/html这个目录中</span><br></code></pre></td></tr></table></figure><h3 id="3-3-1-案例-数据卷挂载-："><a href="#3-3-1-案例-数据卷挂载-：" class="headerlink" title="3.3.1 案例(数据卷挂载)："></a>3.3.1 案例(数据卷挂载)：</h3><p>​    创建nginx容器，修改容器内的html目录内的index.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume create html  #创建html数据卷<br>docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br><span class="hljs-meta">#</span><span class="bash"> 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-meta">#</span><span class="bash"> 进入该目录（Linux）</span><br>cd /var/lib/docker/volumes/html/_data<br><span class="hljs-meta">#</span><span class="bash"> 修改文件（Linux）</span><br>vi index.html<br></code></pre></td></tr></table></figure><blockquote><p>windows中关联数据卷，进入</p><p>file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/html/_data目录下，修改index.html</p></blockquote><h3 id="3-3-2-案例-宿主机目录挂载"><a href="#3-3-2-案例-宿主机目录挂载" class="headerlink" title="3.3.2 案例(宿主机目录挂载)"></a>3.3.2 案例(宿主机目录挂载)</h3><p>windows：</p><ul><li>路径盘符要小写</li><li>文件夹名称不能有空格</li><li>文件最好提前创建，不然自动创建出来的是个文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name myNginx -p 80:80 -d -v d:\AppData\docker\volumes\html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure><blockquote><p>​    在计算机的<code>d:\AppData\docker\volumes\html</code>目录下，新增或变更资源，都会同步到nginx的<code>/usr/share/nginx/html</code>目录中</p></blockquote><p>目录挂载与数据卷挂载的语法是类似的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v [宿主机目录]:[容器内目录]<br>-v [宿主机文件]:[容器内文件]<br></code></pre></td></tr></table></figure><h3 id="3-3-3-数据卷挂载与目录直接挂载的区别"><a href="#3-3-3-数据卷挂载与目录直接挂载的区别" class="headerlink" title="3.3.3 数据卷挂载与目录直接挂载的区别"></a>3.3.3 数据卷挂载与目录直接挂载的区别</h3><p>数据卷挂载：(自动化但隐藏细节) 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</p><p>目录挂载: (细节自己实现，没有自动化) 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</p><h1 id="4、Dockerfile自定义镜像"><a href="#4、Dockerfile自定义镜像" class="headerlink" title="4、Dockerfile自定义镜像"></a>4、Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="4-1-镜像结构"><a href="#4-1-镜像结构" class="headerlink" title="4.1 镜像结构"></a>4.1 镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><blockquote><p>底层函数库 -》 环境配置 -》依赖安装 -》应用安装 -》应用配置</p></blockquote><p><img src="D:\git-data\CherishLLBlog\source\img\blogImg\imageStruct.png" alt="模拟Mysql镜像结构"></p><p>镜像是分层结构，每一层称为一个Layer</p><p>简单来说，镜像就是在系统函数库、运行环境<strong>基础</strong>上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="4-2-Dockerfile语法"><a href="#4-2-Dockerfile语法" class="headerlink" title="4.2 Dockerfile语法"></a>4.2 Dockerfile语法</h2><h3 id="4-2-1-什么是Dockerfile"><a href="#4-2-1-什么是Dockerfile" class="headerlink" title="4.2.1 什么是Dockerfile"></a>4.2.1 什么是Dockerfile</h3><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">指定基础镜像</td><td align="center">FROM centos:6</td></tr><tr><td align="center">ENV</td><td align="center">设置环境变量，可在后面指令使用</td><td align="center">ENV key value</td></tr><tr><td align="center">COPY</td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center">COPY ./mysql-5.7.rpm /tmp</td></tr><tr><td align="center">RUN</td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center">RUN yum install gcc</td></tr><tr><td align="center">EXPOSE</td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>更新详细语法说明，请参考<a href="https://docs.docker.com/engine/reference/builder">官网文档</a></p><h2 id="4-3-构建Java项目"><a href="#4-3-构建Java项目" class="headerlink" title="4.3 构建Java项目"></a>4.3 构建Java项目</h2><h3 id="4-3-1-基于Ubuntu构建Java项目"><a href="#4-3-1-基于Ubuntu构建Java项目" class="headerlink" title="4.3.1 基于Ubuntu构建Java项目"></a>4.3.1 基于Ubuntu构建Java项目</h3><p>​    需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p></li><li><p>步骤2：拷贝docker-demo.jar文件到docker-demo这个目录</p></li><li><p>步骤3：拷贝jdk8.tar.gz文件到docker-demo这个目录</p></li><li><p>步骤4：拷贝Dockerfile到docker-demo这个目录</p></li></ul><p>Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span><br><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure><ul><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><p>构建镜像</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t javaweb:1.0 .<br></code></pre></td></tr></table></figure><h3 id="4-3-2-基于java8构建Java项目"><a href="#4-3-2-基于java8构建Java项目" class="headerlink" title="4.3.2 基于java8构建Java项目"></a>4.3.2 基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs doc">FROM java:8-alpine<br>COPY ./app.jar /tmp/app.jar<br>EXPOSE 8090<br>ENTRYPOINT java -jar /tmp/app.jar<br></code></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h3 id="4-3-3-小结"><a href="#4-3-3-小结" class="headerlink" title="4.3.3 小结"></a>4.3.3 小结</h3><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="5、DockerCompose"><a href="#5、DockerCompose" class="headerlink" title="5、DockerCompose"></a>5、DockerCompose</h1><p>Docker Compose可以基于<strong>Compose文件</strong>帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><h2 id="5-1-初始DockerCompose"><a href="#5-1-初始DockerCompose" class="headerlink" title="5.1 初始DockerCompose"></a>5.1 初始DockerCompose</h2><p>Compose文件是一个<strong>文本文件</strong>，通过<strong>指令</strong>定义集群中的每个容器如何运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> <span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-string">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">environment:</span><br>     <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span> <br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-string">-</span> <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     <span class="hljs-string">-</span> <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-string">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8090:8090&quot;</span><br></code></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考<a href="https://docs.docker.com/compose/compose-file/">官网</a></p><p>其实DockerCompose文件可以看做是将多个<code>docker run</code>命令写到一个文件，只是语法稍有差异。</p><h2 id="5-2-安装DockerCompose"><a href="#5-2-安装DockerCompose" class="headerlink" title="5.2 安装DockerCompose"></a>5.2 安装DockerCompose</h2><p>参考[docker的介绍与安装]</p><h2 id="5-3-部署微服务集群"><a href="#5-3-部署微服务集群" class="headerlink" title="5.3 部署微服务集群"></a>5.3 部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h1 id="6、Docker镜像仓库"><a href="#6、Docker镜像仓库" class="headerlink" title="6、Docker镜像仓库"></a>6、Docker镜像仓库</h1><h2 id="6-1搭建私有镜像仓库"><a href="#6-1搭建私有镜像仓库" class="headerlink" title="6.1搭建私有镜像仓库"></a>6.1搭建私有镜像仓库</h2><p>参考[docker的介绍与安装]</p><h2 id="6-2-推送、拉取镜像"><a href="#6-2-推送、拉取镜像" class="headerlink" title="6.2 推送、拉取镜像"></a>6.2 推送、拉取镜像</h2><p>推送镜像到<strong>私有镜像</strong>服务<strong>必须先tag</strong>，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的安装</title>
    <link href="/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <url>/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Docker基本概念"><a href="#1、Docker基本概念" class="headerlink" title="1、Docker基本概念"></a>1、Docker基本概念</h1><h2 id="1-1-Docker初识"><a href="#1-1-Docker初识" class="headerlink" title="1.1 Docker初识"></a>1.1 Docker初识</h2><p>​    Docker是一个开源的应用容器框架</p><p>​    基于Go语言实现</p><p>​    Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。</p><p>​    容器完全使用<strong>沙箱机制</strong>，相互隔离</p><p>​    容器性能开销极低</p><p>​    <strong>小结：docker是一个容器技术，解决软件跨环境迁移的问题</strong></p><h2 id="1-2-Docker解决兼容性问题"><a href="#1-2-Docker解决兼容性问题" class="headerlink" title="1.2 Docker解决兼容性问题"></a>1.2 Docker解决兼容性问题</h2><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p>为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3 Docker架构"></a>1.3 Docker架构</h2><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。一个镜像可以运行多个容器</p><p>是一个C/S架构的程序，有两部分组成：</p><ul><li>服务端：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>客户端：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><p>Docker的工作流：</p><ul><li><p>构建自定义镜像或者从DockerRegistry拉取镜像</p></li><li><p>根据镜像创建容器，并运行</p></li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4 安装Docker"></a>1.4 安装Docker</h2><h3 id="1-4-1-安装Windows版"><a href="#1-4-1-安装Windows版" class="headerlink" title="1.4.1 安装Windows版"></a>1.4.1 安装Windows版</h3><pre><code>此处参考[博客](https://www.cnblogs.com/wangyang0210/p/13212610.html)</code></pre><h3 id="1-4-2-Linux版-CentOS-7-为例"><a href="#1-4-2-Linux版-CentOS-7-为例" class="headerlink" title="1.4.2 Linux版(CentOS 7 为例)"></a>1.4.2 Linux版(CentOS 7 为例)</h3><p>Docker 分为CE和EE两大版本。</p><p>Linux版：Docker CE支持64位版本CentOS 7，并且要求内核版本不低于3.10，CentOS 7 满足最低内核要求。</p><h4 id="1-4-2-1-卸载（可选）"><a href="#1-4-2-1-卸载（可选）" class="headerlink" title="1.4.2.1 卸载（可选）"></a>1.4.2.1 卸载（可选）</h4><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#反斜杠的作用是连接作用</span></span><br>yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine \<br>                  docker-ce<br></code></pre></td></tr></table></figure><h4 id="1-4-2-2-安装yum工具"><a href="#1-4-2-2-安装yum工具" class="headerlink" title="1.4.2.2 安装yum工具"></a>1.4.2.2 安装yum工具</h4><p>首先需要虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils \<br>           device-mapper-persistent-data \<br>           lvm2 --skip-broken<br></code></pre></td></tr></table></figure><p>更新XFS文件系统管理工具及本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update xfsprogs -y<br></code></pre></td></tr></table></figure><p>然后更新本地镜像源:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#设置docker镜像源</span></span><br>yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>    <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#解决域名问题</span></span><br>sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><h4 id="1-4-2-3-安装docker（ce版本）"><a href="#1-4-2-3-安装docker（ce版本）" class="headerlink" title="1.4.2.3 安装docker（ce版本）"></a>1.4.2.3 安装docker（ce版本）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y docker-ce  ##-y 安装过程中不用询问，问就是yes<br></code></pre></td></tr></table></figure><h4 id="1-4-2-4-启动docker"><a href="#1-4-2-4-启动docker" class="headerlink" title="1.4.2.4 启动docker"></a>1.4.2.4 启动docker</h4><p>Docker应用需要用到各种端口，逐一去修改防火墙设置，会非常麻烦，建议<strong>关闭防火墙</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 关闭</span><br>systemctl stop firewalld<br><span class="hljs-meta">#</span><span class="bash"> 禁止开机启动防火墙</span><br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><p>通过命令启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#启动后查看docker版本</span></span><br>docker --version<br></code></pre></td></tr></table></figure><h4 id="1-4-2-5-配置docker镜像"><a href="#1-4-2-5-配置docker镜像" class="headerlink" title="1.4.2.5 配置docker镜像"></a>1.4.2.5 配置docker镜像</h4><p>docker官方镜像仓库网速较差，我们需要设置国内镜像：</p><p>参考阿里云的<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">镜像加速文档</a></p><h3 id="1-4-3-win10-安装docker-desktop"><a href="#1-4-3-win10-安装docker-desktop" class="headerlink" title="1.4.3 win10 安装docker desktop"></a>1.4.3 win10 安装docker desktop</h3><p>参考<a href="https://www.cnblogs.com/wangyang0210/p/13212610.html">博客</a></p><h1 id="2、安装DockerCompose"><a href="#2、安装DockerCompose" class="headerlink" title="2、安装DockerCompose"></a>2、安装DockerCompose</h1><h2 id="2-1-Linux版本"><a href="#2-1-Linux版本" class="headerlink" title="2.1 Linux版本"></a>2.1 Linux版本</h2><h3 id="2-1-1-下载"><a href="#2-1-1-下载" class="headerlink" title="2.1.1 下载"></a>2.1.1 下载</h3><p>Linux下需要通过命令下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装</span><br>curl -L https://github.com/docker/compose/releases/download/1.29.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="2-1-2-修改文件权限"><a href="#2-1-2-修改文件权限" class="headerlink" title="2.1.2 修改文件权限"></a>2.1.2 修改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改权限</span><br>chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="2-1-3-Base自动补全命令"><a href="#2-1-3-Base自动补全命令" class="headerlink" title="2.1.3 Base自动补全命令"></a>2.1.3 Base自动补全命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 补全命令</span><br>curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose<br></code></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="2-2-Window安装"><a href="#2-2-Window安装" class="headerlink" title="2.2 Window安装"></a>2.2 Window安装</h2><h3 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h3><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><h3 id="2-2-2-安装"><a href="#2-2-2-安装" class="headerlink" title="2.2.2 安装"></a>2.2.2 安装</h3><p>双击下载的安装包直接安装</p><h1 id="3、Docker镜像仓库"><a href="#3、Docker镜像仓库" class="headerlink" title="3、Docker镜像仓库"></a>3、Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1 简化版镜像仓库"></a>3.1 简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --restart=always \<br>    --name registry\<br>    -p 5000:5000 \<br>    -v registry-data:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2 带有图形化界面版本"></a>3.2 带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry</p><p>docker-compose.yml文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./registry-data:/var/lib/registry</span><br>  <span class="hljs-attr">ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">joxit/docker-registry-ui:static</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_TITLE=私有仓库</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_URL=http://registry:5000</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br></code></pre></td></tr></table></figure><p>执行命令构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3 配置Docker信任地址"></a>3.3 配置Docker信任地址</h2><p>我们的私服采用的http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#打开要修改的文件</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment">#添加内容</span><br><span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;http://192.168.150.101:8080&quot;</span>]<br><span class="hljs-comment">#重加载</span><br>systemctl daemon-reload<br><span class="hljs-comment">#重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json字符串与对象的互转</title>
    <link href="/2021/12/03/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E8%BD%AC/"/>
    <url>/2021/12/03/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>在开发过程中，经常需要和别的系统交换数据，数据交换的格式有XML、JSON等，JSON作为一个轻量级的数据格式比xml效率要高，XML需要很多的标签，这无疑占据了网络流量，JSON在这方面则做的很好，下面先看下JSON的格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;JSON&quot;</span>,<span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京市西城区&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">25</span>&#125;<span class="hljs-comment">//JSON的对象格式的字符串</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;com.lyq.pojo.Student&quot;</span>,&#123;<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;211&quot;</span>,<span class="hljs-attr">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-attr">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-attr">&quot;db&quot;</span>:<span class="hljs-string">&quot;mysql&quot;</span>&#125;]<span class="hljs-comment">//数组对象格式</span><br></code></pre></td></tr></table></figure><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>​    要实现JSON与java对象之间的互转，需要借助<strong>第三方jar包</strong>，此处使用json-lib这个jar包，可以冲<a href="https://mvnrepository.com/">此处</a>下载相关jar包，json-lib需要<code>commons-beanutils-1.8.0.jar、commons-collections-3.2.1.jar、commons-lang-2.5.jar、commons-logging-1.1.1.jar、ezmorph-1.0.6.jar </code>五个包的支持。</p><p>json-lib提供了几个类可以完成此功能，例<code>JSONObject、JSONArray</code>从类的名字上可以看出JSONObject转化的应该是对象格式的，而JSONArray转化的则应该是数组对象（即，带[]形式）的。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>jdk15<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ezmorph<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ezmorph<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、Java普通对象和JSON字符串的互转"><a href="#2、Java普通对象和JSON字符串的互转" class="headerlink" title="2、Java普通对象和JSON字符串的互转"></a>2、Java普通对象和JSON字符串的互转</h2><h3 id="2-1-Java对象-–》Json字符串"><a href="#2-1-Java对象-–》Json字符串" class="headerlink" title="2.1 Java对象 –》Json字符串"></a>2.1 Java对象 –》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String stuno;<br>    <span class="hljs-keyword">private</span> String stuname;<br>    <span class="hljs-keyword">private</span> String stusex;<br>    <span class="hljs-keyword">private</span> String db;<br>    <br>    <span class="hljs-comment">//此处省略setter和getter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    Java对象转Json字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Student对象通过JSONObject和JSONArray两种方式转Json字符串</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertObject</span><span class="hljs-params">()</span> </span>&#123;        <br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;成武&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        JSONObject json = JSONObject.fromObject(stu);<br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray array=JSONArray.fromObject(stu);<br>        <br>        String strJson=json.toString();<br>        String strArray=array.toString();<br>        <br>        System.out.println(<span class="hljs-string">&quot;strJson:&quot;</span>+strJson);<br>        System.out.println(<span class="hljs-string">&quot;strArray:&quot;</span>+strArray);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面为打印结果：</p><blockquote><p>strJson:{“db”:”Mysql”,”id”:3,”stuname”:”成武”,”stuno”:”100”,”stusex”:”M”}<br>strArray:[{“db”:”Mysql”,”id”:3,”stuname”:”成武”,”stuno”:”100”,”stusex”:”M”}]</p></blockquote><p>​    两种方法都可以把java对象转化为JSON字符串，只是转化后的<strong>结构</strong>不同。</p><h3 id="2-2-JSON字符串-—》Java对象"><a href="#2-2-JSON字符串-—》Java对象" class="headerlink" title="2.2 JSON字符串 —》Java对象"></a>2.2 JSON字符串 —》Java对象</h3><p>​    首先需要定义两种不同格式的字符串，需要使用\对双引号进行转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonStrToJava</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//定义两种不同格式的字符串</span><br>        String objectStr=<span class="hljs-string">&quot;&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;李四\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;&quot;</span>;<br>        String arrayStr=<span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;李四\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;]&quot;</span>;<br>    <br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        JSONObject jsonObject=JSONObject.fromObject(objectStr);<br>        Student stu=(Student)JSONObject.toBean(jsonObject, Student.class);<br>        <br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray jsonArray=JSONArray.fromObject(arrayStr);<br>        <span class="hljs-comment">//获得jsonArray的第一个元素</span><br>        Object o=jsonArray.get(<span class="hljs-number">0</span>);<br>        JSONObject jsonObject2=JSONObject.fromObject(o);<br>        Student stu2=(Student)JSONObject.toBean(jsonObject2, Student.class);<br>        System.out.println(<span class="hljs-string">&quot;stu:&quot;</span>+stu);<br>        System.out.println(<span class="hljs-string">&quot;stu2:&quot;</span>+stu2);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面为打印结果：</p><blockquote><p>stu:Student{id=3, stuno=’100’, stuname=’李四’, stusex=’M’, db=’Mysql’}<br>stu2:Student{id=3, stuno=’100’, stuname=’李四’, stusex=’M’, db=’Mysql’}</p></blockquote><p>​    使用<code>JSONObject</code>可以轻松的把JSON格式的字符串转化为java对象，但是使用<code>JSONArray</code>就没那么容易了，因为它有<strong>“[]”</strong>符号，所以我们这里在<strong>获得了JSONArray的对象之后</strong>，<strong>取其第一个元素</strong>即我们需要的一个student的变形，然后使用JSONObject轻松获得</p><h2 id="3、list和json字符串的互转"><a href="#3、list和json字符串的互转" class="headerlink" title="3、list和json字符串的互转"></a>3、<strong>list和json字符串的互转</strong></h2><h3 id="3-1-list-–》Json字符串"><a href="#3-1-list-–》Json字符串" class="headerlink" title="3.1 list –》Json字符串"></a>3.1 list –》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listToJSON</span><span class="hljs-params">()</span></span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;王建&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br>        Student stu2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;102&quot;</span>, <span class="hljs-string">&quot;李承&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        List&lt;Student&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>        lists.add(stu);<br>        lists.add(stu2);<br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        <span class="hljs-comment">//JSONObject listObject=JSONObject.fromObject(lists);//会报错</span><br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray listArray=JSONArray.fromObject(lists);<br><br>        <span class="hljs-comment">//System.out.println(&quot;listObject:&quot;+listObject.toString());</span><br>        System.out.println(<span class="hljs-string">&quot;listArray:&quot;</span>+listArray.toString());<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>​    我把使用JSONObject的方式给注掉了，我们先看注释之前的结果：</p><blockquote><p>net.sf.json.JSONException: ‘object’ is an array. Use JSONArray instead</p></blockquote><p>​    注释后，正确执行结果为：</p><blockquote><p>listArray:[{“db”:”Mysql”,”id”:4,”stuname”:”王建”,”stuno”:”101”,”stusex”:”M”},{“db”:”Mysql”,”id”:5,”stuname”:”李承”,”stuno”:”102”,”stusex”:”N”}]</p></blockquote><h3 id="3-2-Json字符串-–》list"><a href="#3-2-Json字符串-–》list" class="headerlink" title="3.2 Json字符串 –》list"></a>3.2 Json字符串 –》list</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonToList</span><span class="hljs-params">()</span></span>&#123;<br>        String arrayStr=<span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:\&quot;4\&quot;,\&quot;stuname\&quot;:\&quot;王建\&quot;,\&quot;stuno\&quot;:\&quot;101\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;]&quot;</span>;<br>        <span class="hljs-comment">//转化为list</span><br>        List&lt;Student&gt; list2=(List&lt;Student&gt;)JSONArray.toList(JSONArray.fromObject(arrayStr), Student.class);<br><br>        <span class="hljs-keyword">for</span> (Student stu : list2) &#123;<br>            System.out.println(stu);<br>        &#125;<br>        <span class="hljs-comment">//转化为数组</span><br>        Student[] ss =(Student[])JSONArray.toArray(JSONArray.fromObject(arrayStr),Student.class);<br>        <span class="hljs-keyword">for</span> (Student student : ss) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;王建&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br>Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;王建&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>由于字符串的格式为带有“[]”的格式，所以这里<strong>选择JSONArray</strong>这个对象，它有<code>toArray、toList</code>方法可供使用，前者转化为java中的<strong>数组</strong>，后者转化为java中的<strong>list</strong>，由于这里有实体类进行对应，所以在使用时指定了泛型的类型（Student.class），这样就可以得到转化后的对象</p><h2 id="4、map和Json字符串的互转"><a href="#4、map和Json字符串的互转" class="headerlink" title="4、map和Json字符串的互转"></a>4、map和Json字符串的互转</h2><h3 id="4-1-Map-—》Json字符串"><a href="#4-1-Map-—》Json字符串" class="headerlink" title="4.1 Map —》Json字符串"></a>4.1 Map —》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mapToJSON</span><span class="hljs-params">()</span></span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;成武&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br>        Student stu1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;王建&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        HashMap&lt;String, Student&gt; stuMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Student&gt;();<br>        stuMap.put(<span class="hljs-string">&quot;first&quot;</span>,stu);<br>        stuMap.put(<span class="hljs-string">&quot;second&quot;</span>,stu1);<br><br>        <span class="hljs-comment">//1、JSONObject</span><br>        JSONObject mapObject= JSONObject.fromObject(stuMap);<br>        System.out.println(<span class="hljs-string">&quot;mapObject&quot;</span>+mapObject.toString());<br><br>        <span class="hljs-comment">//2、JSONArray</span><br>        JSONArray mapArray=JSONArray.fromObject(stuMap);<br>        System.out.println(<span class="hljs-string">&quot;mapArray:&quot;</span>+mapArray.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mapObject</span>&#123;<span class="hljs-string">&quot;first&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;成武&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;100&quot;</span>&#125;,<span class="hljs-string">&quot;second&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;王建&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;101&quot;</span>&#125;&#125;<br><span class="hljs-attribute">mapArray</span>:[&#123;<span class="hljs-string">&quot;first&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;成武&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;100&quot;</span>&#125;,<span class="hljs-string">&quot;second&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;王建&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;101&quot;</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><h3 id="4-2-Json字符串-—》Map"><a href="#4-2-Json字符串-—》Map" class="headerlink" title="4.2 Json字符串 —》Map"></a>4.2 Json字符串 —》Map</h3><p>JSON字符串不能直接转化为map对象，要想取得map中的键对应的值需要别的方式，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Student first;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(Student first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonToMap</span><span class="hljs-params">()</span></span>&#123;<br>        String strObject=<span class="hljs-string">&quot;&#123;\&quot;first\&quot;:&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;成武\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;&#125;&quot;</span>;<br><br>        <span class="hljs-comment">//JSONObject</span><br>        JSONObject jsonObject=JSONObject.fromObject(strObject);<br>        Map map=<span class="hljs-keyword">new</span> HashMap();<br>        map.put(<span class="hljs-string">&quot;first&quot;</span>, Student.class);<br><br>        <span class="hljs-comment">//使用了toBean方法，需要三个参数</span><br>        MyBean my=(MyBean)JSONObject.toBean(jsonObject, MyBean.class, map);<br>        System.out.println(my.getFirst());<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;成武&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>使用toBean()方法是传入了三个参数，第一个是JSONObject对象，第二个是MyBean.class，第三个是一个Map对象。通过MyBean可以知道此类中要有一个first的属性，且其类型为Student，要和map中的键和值类型对应，即，first对应键 first类型对应值的类型。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown的基本使用</title>
    <link href="/2021/12/01/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/01/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Markdown标题"><a href="#1、Markdown标题" class="headerlink" title="1、Markdown标题"></a>1、Markdown标题</h1><h2 id="1-1-使用-和-标记一级和二级标题"><a href="#1-1-使用-和-标记一级和二级标题" class="headerlink" title="1.1 使用 = 和 - 标记一级和二级标题"></a>1.1 使用 = 和 - 标记一级和二级标题</h2><p>= 和 - 标记语法格式如下:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我展示的是一级标题</span><br><span class="hljs-section">=================</span><br><br><span class="hljs-section">我展示的是二级标题</span><br><span class="hljs-section">-----------------</span><br></code></pre></td></tr></table></figure><h2 id="1-2-使用-号标记"><a href="#1-2-使用-号标记" class="headerlink" title="1.2 使用#号标记"></a>1.2 使用#号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><h1 id="2、段落格式"><a href="#2、段落格式" class="headerlink" title="2、段落格式"></a>2、段落格式</h1><h2 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2.1 字体"></a>2.1 字体</h2><p>markdown可以使用一下几种字体</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><h2 id="2-2-分割线"><a href="#2-2-分割线" class="headerlink" title="2.2 分割线"></a>2.2 分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span> <span class="hljs-emphasis">* *</span></span><br><span class="hljs-strong"></span><br><span class="hljs-strong">**</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">- - -</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">----------</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~BAIDU.COM~~<br></code></pre></td></tr></table></figure><p>效果如：<del>BAIDU.COM</del></p><h2 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h2><p>下划线可以通过 HTML 的 <code>^&lt;u&gt;</code> 标签来实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果为： <u>带下划线文本</u></p><h2 id="2-5-注脚"><a href="#2-5-注脚" class="headerlink" title="2.5 注脚"></a>2.5 注脚</h2><p>脚注是对文本的补充说明。Markdown 脚注的格式如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[^要注明的文本]<br></code></pre></td></tr></table></figure><h1 id="3、Markdown-列表"><a href="#3、Markdown-列表" class="headerlink" title="3、Markdown 列表"></a>3、Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p><h2 id="3-1无序列表"><a href="#3-1无序列表" class="headerlink" title="3.1无序列表"></a>3.1无序列表</h2><p>  使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要<strong>添加一个空格</strong>，然后再填写内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><h2 id="3-2有序列表"><a href="#3-2有序列表" class="headerlink" title="3.2有序列表"></a>3.2有序列表</h2><p>  使用数字并加上 . 号来表示，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><h2 id="3-3-列表嵌套"><a href="#3-3-列表嵌套" class="headerlink" title="3.3 列表嵌套"></a>3.3 列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项：<br><span class="hljs-bullet">    -</span> 第一项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第一项嵌套的第二个元素<br><span class="hljs-bullet">2.</span> 第二项：<br><span class="hljs-bullet">    -</span> 第二项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第二项嵌套的第二个元素<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="4、Markdown区块"><a href="#4、Markdown区块" class="headerlink" title="4、Markdown区块"></a>4、Markdown区块</h1><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">区块引用</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">菜鸟教程</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">学的不仅是技术更是梦想</span><br></code></pre></td></tr></table></figure><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">最外层</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; 第一层嵌套</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure><p>展示效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="4-1-区块中使用列表"><a href="#4-1-区块中使用列表" class="headerlink" title="4.1 区块中使用列表"></a>4.1 区块中使用列表</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">区块中使用列表</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第一项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第二项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><p>显示结果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><h2 id="4-2-列表中使用区块"><a href="#4-2-列表中使用区块" class="headerlink" title="4.2 列表中使用区块"></a>4.2 列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前<strong>添加四个空格</strong>的缩进。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>第一项<br><span class="hljs-code">    &gt; 菜鸟教程</span><br><span class="hljs-code">    &gt; 学的不仅是技术更是梦想</span><br><span class="hljs-bullet">* </span>第二项<br></code></pre></td></tr></table></figure><p>显示效果如下</p><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h1 id="5、Markdown代码"><a href="#5、Markdown代码" class="headerlink" title="5、Markdown代码"></a>5、Markdown代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`printf()` 函数<br></code></pre></td></tr></table></figure><p>显示效果为： <code>printf()</code> 函数</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>也可以使用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><h1 id="6、Markdown-链接"><a href="#6、Markdown-链接" class="headerlink" title="6、Markdown 链接"></a>6、Markdown 链接</h1><h2 id="6-1-使用方法："><a href="#6-1-使用方法：" class="headerlink" title="6.1 使用方法："></a>6.1 使用方法：</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[链接名称]</span>(链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：<code>这是一个链接 [菜鸟教程](https://www.runoob.com)</code><br>效果为：这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>直接使用链接地址： <code>&lt;https://www.runoob.com&gt;</code><br>效果为：<a href="https://www.runoob.com/">https://www.runoob.com</a></p><h2 id="6-2-高级链接"><a href="#6-2-高级链接" class="headerlink" title="6.2 高级链接"></a>6.2 高级链接</h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less">这个链接用 <span class="hljs-selector-tag">1</span> 作为网址变量 <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[1]</span><br>这个链接用 <span class="hljs-selector-tag">runoob</span> 作为网址变量 <span class="hljs-selector-attr">[Runoob]</span><span class="hljs-selector-attr">[runoob]</span><br>然后在文档的结尾为变量赋值（网址）<br><br>  <span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.google.com/</span><br>  <span class="hljs-selector-attr">[runoob]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.runoob.com/</span><br></code></pre></td></tr></table></figure><p>效果为：<br>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="7、Markdown-图片"><a href="#7、Markdown-图片" class="headerlink" title="7、Markdown 图片"></a>7、Markdown 图片</h1><p>Markdown 图片语法格式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址)<br><br>!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址 <span class="hljs-string">&quot;可选标题&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>使用实例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p>显示效果为:<br><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">这个链接用 <span class="hljs-number">1</span> 作为网址变量 [RUNOOB][<span class="hljs-number">1</span>].<br>然后在文档的结尾为变量赋值（网址）<br><br>[<span class="hljs-number">1</span>]: http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png<br></code></pre></td></tr></table></figure><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="8、Markdown-表格"><a href="#8、Markdown-表格" class="headerlink" title="8、Markdown 表格"></a>8、Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行<br>语法格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><p>显示的效果为：<br>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br>对齐方式<br>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。、<br>实例如下：<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure>显示效果为为：<table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/27/hello-world/"/>
    <url>/2021/11/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! 这是hexo自动生成的第一个欢迎也面. 查看 <a href="https://hexo.io/docs/">文档</a> 了解更多信息. 如果您在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">疑难解答</a>中找到答案 ,也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>上询问我.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建一个新的也面"><a href="#创建一个新的也面" class="headerlink" title="创建一个新的也面"></a>创建一个新的也面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动blog服务"><a href="#启动blog服务" class="headerlink" title="启动blog服务"></a>启动blog服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到远端"><a href="#发布到远端" class="headerlink" title="发布到远端"></a>发布到远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
