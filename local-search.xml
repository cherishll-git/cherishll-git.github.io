<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nacos安装指南</title>
    <link href="/2021/12/16/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2021/12/16/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高</p><span id="more"></span><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><img src="/img/SpringCloud/nacos01.png" alt="nacos安装目录1" style="zoom:60%;" /><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p>application.properties文件，修改其中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><img src="/img/SpringCloud/nacos02.png" alt="nacos的bin目录" style="zoom:60%;" /><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><img src="/img/SpringCloud/nacos03.png" alt="nacos启动" style="zoom:60%;" /><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF">http://127.0.0.1:8848/nacos即可</a>:</p><img src="/img/SpringCloud/nacos04.png" alt="nacos登录页" style="zoom:40%;" /><p>默认的账号和密码都是nacos，进入后：</p><img src="/img/SpringCloud/nacos05.png" alt="nacos首页" style="zoom:50%;" /><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf jdk-8u144-linux-x64.tar.gz<br></code></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/<span class="hljs-built_in">local</span>/java<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>上传nacos-server-1.4.1.tar.gz：</p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rm -rf nacos-server-1.4.1.tar.gz<br></code></pre></td></tr></table></figure><p>目录内部：</p><img src="/img/SpringCloud/nacos06.png" alt="nacos首页" style="zoom:50%;" /><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh -m standalone<br></code></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nacos</tag>
      
      <tag>注册中心</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义starterr</title>
    <link href="/2021/12/15/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starterr/"/>
    <url>/2021/12/15/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starterr/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SPI机制</title>
    <link href="/2021/12/09/SPI%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/12/09/SPI%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    <strong>SPI</strong> ，全称为 <strong>Service Provider Interface</strong>，是一种<strong>服务发现机制</strong>。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><span id="more"></span><p>Java SPI 实际上是<strong>“基于接口的编程＋策略模式＋配置文件”</strong>组合实现的<strong>动态加载机制</strong>。</p><h1 id="1、SPI具体约定"><a href="#1、SPI具体约定" class="headerlink" title="1、SPI具体约定"></a>1、SPI具体约定</h1><ul><li><p>当服务的提供者，提供了服务接口的一种实现之后，在jar包的<code>META-INF/services/</code>目录里目录下创建一个接口的<strong>全限定名</strong>的文件，该文件的内容是是实现类的全限定名；</p></li><li><p>当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p></li></ul><p>基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：<code>java.util.ServiceLoader</code></p><h1 id="2、SPI简单Demo"><a href="#2、SPI简单Demo" class="headerlink" title="2、SPI简单Demo"></a>2、SPI简单Demo</h1><h2 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h2><img src="/img/blogImg/spiProjectStruct.png" alt="" style="zoom:50%;" /><h2 id="2-2-SPI-Demo的代码："><a href="#2-2-SPI-Demo的代码：" class="headerlink" title="2.2 SPI Demo的代码："></a>2.2 SPI Demo的代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lyq.service;<br><span class="hljs-comment">//定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PayMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPayMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//两个实现类</span><br><span class="hljs-keyword">package</span> com.lyq.service.impl;<br><br><span class="hljs-keyword">import</span> com.lyq.service.PayMethod;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliPayMethod</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PayMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPayMethod</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;ali pay&quot;</span>);&#125;<br>&#125;<br><br>==============类分割线==================<br><br><span class="hljs-keyword">package</span> com.lyq.service.impl;<br><br><span class="hljs-keyword">import</span> com.lyq.service.PayMethod;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeChatPayMethod</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PayMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPayMethod</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;wechat pay&quot;</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后要在ClassPath路径下配置添加一个文件。文件名字是接口的<strong>全限定类名（com.lyq.service.PayMethod）</strong>，内容是<strong>实现类的全限定类名</strong>，多个实现类用<strong>换行符</strong>分隔。</p><p>com.lyq.service.PayMethod：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.lyq</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.AliPayMethod</span><br>com<span class="hljs-selector-class">.lyq</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span>.WeChatPayMethod<br></code></pre></td></tr></table></figure><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPIDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 直接实例化耦合度较高</span><br><span class="hljs-comment">         */</span><br>        PayMethod aliPayMethod = <span class="hljs-keyword">new</span> AliPayMethod();<br>        aliPayMethod.getPayMethod();<br>        PayMethod weChatPayMethod = <span class="hljs-keyword">new</span> WeChatPayMethod();<br>        weChatPayMethod.getPayMethod();<br>        System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 解耦灵活配置法</span><br><span class="hljs-comment">         */</span><br>        testSPI();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSPI</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//把我们的接口类型保存到ServiceLoader中 service变量</span><br>        <span class="hljs-comment">//创建了lazyIterator对象 （把我们的接口保存     保存我们的classLoader）</span><br>        ServiceLoader&lt;PayMethod&gt; load = ServiceLoader.load(PayMethod.class);<br><br>        <span class="hljs-comment">//或者Service.providers()方法获取我们的Iterator对象</span><br>        <span class="hljs-comment">//Iterator&lt;PayMethod&gt; iterator  = Service.providers(PayMethod.class);</span><br><br>        Iterator&lt;PayMethod&gt; iterator = load.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            PayMethod next = iterator.next();<br>            next.getPayMethod();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过spi机制也可以像我们new对象一样获取实例！</strong>执行结果如下：</p><blockquote><p>ali pay<br>wechat pay</p><p>==========================</p><p>ali pay<br>wechat pay</p></blockquote><h2 id="2-4-分析"><a href="#2-4-分析" class="headerlink" title="2.4 分析"></a>2.4 分析</h2><p><strong>为什么不直接new而是用spi实现呢？</strong></p><p>​        与我们java设计相关，系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则；实际用时AliPayMethod支付，如果觉得AliPay支付方式不实用，需要替换一种实现，比如将我们的AliPay支付换成WeChatPay支付，就需要修改代码。</p><p>为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p><p>Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。</p><h1 id="3、适用场景"><a href="#3、适用场景" class="headerlink" title="3、适用场景"></a>3、适用场景</h1><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</p><p>比较常见的例子：</p><ul><li>数据库驱动加载接口实现类的加载</li><li>JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载</li><li>SLF4J加载不同提供商的日志实现类</li></ul><p><strong>Spring</strong><br>Spring中大量使用了SPI, 比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等<br><strong>Dubbo</strong><br>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</p><h1 id="4、源码分析"><a href="#4、源码分析" class="headerlink" title="4、源码分析"></a>4、源码分析</h1><h2 id="4-1-ServiceLoader-load-为例"><a href="#4-1-ServiceLoader-load-为例" class="headerlink" title="4.1 ServiceLoader.load()为例"></a>4.1 ServiceLoader.load()为例</h2><h3 id="4-1-1-成员变量"><a href="#4-1-1-成员变量" class="headerlink" title="4.1.1 成员变量"></a>4.1.1 成员变量</h3><p>首先看看ServiceLoader类的签名类的<strong>成员变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLoader</span>&lt;<span class="hljs-title">S</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br><br><span class="hljs-comment">//指定的配置文件的路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">&quot;META-INF/services/&quot;</span>;<br><br>    <span class="hljs-comment">// 代表被加载的类或者接口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;<br><br>    <span class="hljs-comment">// 用于定位，加载和实例化providers的类加载器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;<br><br>    <span class="hljs-comment">// 创建ServiceLoader时采用的访问控制上下文</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;<br><br>     <span class="hljs-comment">// 缓存providers，按实例化的顺序排列</span><br>    <span class="hljs-keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 懒查找迭代器 (内部类，真正加载服务类)</span><br>    <span class="hljs-keyword">private</span> LazyIterator lookupIterator;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-2-Load"><a href="#4-1-2-Load" class="headerlink" title="4.1.2 Load"></a>4.1.2 Load</h3><p><code>ServiceLoader.load</code>方法内创建一个新的ServiceLoader，并实例化该类中的成员变量，主要包括四大步骤：</p><p>​    1、loader（ClassLoader类型，类加载器）</p><p>​    2、acc（AccessControlContext类型，访问控制器）</p><p>​    3、providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</p><p>​    4、lookupIterator(实现迭代器功能)</p><p>重要源码提炼如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>ClassLoader cl = Thread.currentThread().getContextClassLoader();<br><span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service,ClassLoader loader)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceLoader&lt;&gt;(service, loader);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ServiceLoader</span><span class="hljs-params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;<br>    <span class="hljs-comment">////要加载的接口</span><br>service = Objects.requireNonNull(svc, <span class="hljs-string">&quot;Service interface cannot be null&quot;</span>);<br>    <span class="hljs-comment">//类加载器</span><br>loader = (cl == <span class="hljs-keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;<br>    <span class="hljs-comment">//访问控制器</span><br>    acc = (System.getSecurityManager() != <span class="hljs-keyword">null</span>) ? AccessController.getContext() : <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//先清空</span><br>    providers.clear();<br>    <span class="hljs-comment">//实例化内部类</span><br>    lookupIterator = <span class="hljs-keyword">new</span> LazyIterator(service, loader);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-3-查找实现类"><a href="#4-1-3-查找实现类" class="headerlink" title="4.1.3 查找实现类"></a>4.1.3 查找实现类</h3><p>查找实现类和创建实现类的过程，都在<code>LazyIterator</code>完成。当我们调用<code>iterator.hasNext</code>和<code>iterator.next</code>方法的时候，<strong>实际上</strong>调用的都是<strong>LazyIterator的相应方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;S&gt;() &#123;<br>        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator();<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            f (knownProviders.hasNext())<br>                    <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点关注</strong><code>lookupIterator.hasNext()</code>方法，它最终会调用到<code>hasNextService</code>。读取<code>META-INF/services/</code>下的配置文件，获得所有能被实例化的类的名称，值得注意的是，<code>ServiceLoader</code>可以跨越jar包获取META-INF下的配置文件，具体加载配置的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br>    Class&lt;S&gt; service;<br>    ClassLoader loader;<br>    Enumeration&lt;URL&gt; configs = <span class="hljs-keyword">null</span>;<br>    Iterator&lt;String&gt; pending = <span class="hljs-keyword">null</span>;<br>    String nextName = <span class="hljs-keyword">null</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNextService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//第二次调用的时候，已经解析完成了，直接返回</span><br>        <span class="hljs-keyword">if</span> (nextName != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//META-INF/services/ 加上接口的全限定类名，就是文件服务类的文件</span><br>            <span class="hljs-comment">//META-INF/services/spi.WordParse</span><br>            String fullName = PREFIX + service.getName();<br>            <span class="hljs-comment">//将文件路径转成URL对象</span><br>            configs = loader.getResources(fullName);<br>        &#125;<br>        <span class="hljs-keyword">while</span> ((pending == <span class="hljs-keyword">null</span>) || !pending.hasNext()) &#123;<br>            <span class="hljs-comment">//解析URL文件对象，读取内容，最后返回</span><br>            pending = parse(service, configs.nextElement());<br>        &#125;<br>        <span class="hljs-comment">//拿到第一个实现类的类名</span><br>        nextName = pending.next();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 创建实例,见4.1.4</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-4-创建实例"><a href="#4-1-4-创建实例" class="headerlink" title="4.1.4 创建实例"></a>4.1.4 创建实例</h3><p>当然，调用next方法的时候，实际调用到的是<code>lookupIterator.nextService</code>。它通过反射的方式，创建实现类的实例并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!hasNextService()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        <span class="hljs-comment">//全限定类名</span><br>        String cn = nextName;<br>        nextName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//创建类的Class对象</span><br>        Class&lt;?&gt; c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>        <span class="hljs-comment">//通过newInstance实例化</span><br>        S p = service.cast(c.newInstance());<br>        <span class="hljs-comment">//放入集合，返回实例</span><br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><h2 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h2><p>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，实现解耦。我们的应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式，让我们不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<code>Class.forName(“com.mysql.jdbc.Driver”)</code>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从这个指定的地方访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类。</p><h2 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h2><ul><li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2021/12/08/RabbitMQ/"/>
    <url>/2021/12/08/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="1、快速入门"><a href="#1、快速入门" class="headerlink" title="1、快速入门"></a>1、快速入门</h1><h2 id="1-1-安装RabbitMQ"><a href="#1-1-安装RabbitMQ" class="headerlink" title="1.1 安装RabbitMQ"></a>1.1 安装RabbitMQ</h2><h3 id="1-1-1-基于docker安装："><a href="#1-1-1-基于docker安装：" class="headerlink" title="1.1.1 基于docker安装："></a>1.1.1 基于docker安装：</h3><p><strong>下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull rabbitmq:3-management<br></code></pre></td></tr></table></figure><p><strong>启动MQ</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --hostname my-rabbit --name rabbitmq -e RABBITMQ_DEFAULT_USER=cherishll -e RABBITMQ_DEFAULT_PASS=123123 -p 15672:15672 -p 5672:5672 rabbitmq:3-management<br></code></pre></td></tr></table></figure><blockquote><p>–hostname 配置的主机名</p><p>-p 15672:15672 rabbitMQ管理平台的端口</p><p>-p 5672:5672 消息通信的端口</p></blockquote><p>启动后访问图形界面 localhost:15672</p><h3 id="1-1-2-MQ的基本结构"><a href="#1-1-2-MQ的基本结构" class="headerlink" title="1.1.2 MQ的基本结构"></a>1.1.2 MQ的基本结构</h3><p><img src="/img/blogImg/image-20210717162752376.png" alt="MQ基本结构"></p><h3 id="1-1-3-RabbitMQ中的角色"><a href="#1-1-3-RabbitMQ中的角色" class="headerlink" title="1.1.3 RabbitMQ中的角色"></a>1.1.3 RabbitMQ中的角色</h3><ul><li>publisher：生产者（负责发布消息）</li><li>consumer：消费者（负责订阅消息）</li><li>exchange：交换机，负责消息路由</li><li>queue：队列，负责接受并缓存消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="1-2-RabbitMQ消息模型"><a href="#1-2-RabbitMQ消息模型" class="headerlink" title="1.2 RabbitMQ消息模型"></a>1.2 RabbitMQ消息模型</h2><p>RabbitMQ<a href="https://www.rabbitmq.com/getstarted.html">官方</a>提供了5个不同的Demo示例，对应了不同的消息模型：</p><ul><li><p>基本消息队列（BasicQueue）</p></li><li><p>工作消息队列（WorkQueue）</p><p><img src="/img/blogImg/mqdemo01.png" alt="demo"></p></li></ul><p>发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：</p><ul><li><p>Fanout Exchange：广播</p></li><li><p>Direct Exchange：路由</p></li><li><p>Topic Exchange：主题</p><p><img src="/img/blogImg/mqdemo02.png" alt="demo02"></p></li></ul><h2 id="1-3-RabbitMQ入门案例"><a href="#1-3-RabbitMQ入门案例" class="headerlink" title="1.3 RabbitMQ入门案例"></a>1.3 RabbitMQ入门案例</h2><h3 id="1-3-1-Demo中的Hello-World案例"><a href="#1-3-1-Demo中的Hello-World案例" class="headerlink" title="1.3.1 Demo中的Hello World案例"></a>1.3.1 Demo中的Hello World案例</h3><h4 id="1-3-1-1项目结构"><a href="#1-3-1-1项目结构" class="headerlink" title="1.3.1.1项目结构"></a>1.3.1.1项目结构</h4><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>​    <img src="/img/blogImg/mqdemocode.png" alt="项目结构" style="zoom:50%;" /></p><p>​    父工程引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-1-2-简单队列模式的模型"><a href="#1-3-1-2-简单队列模式的模型" class="headerlink" title="1.3.1.2 简单队列模式的模型"></a>1.3.1.2 简单队列模式的模型</h4><p><img src="/img/blogImg/image-20210717163434647.png" alt="模型"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h4 id="1-3-1-3-publisher实现"><a href="#1-3-1-3-publisher实现" class="headerlink" title="1.3.1.3 publisher实现"></a>1.3.1.3 publisher实现</h4><ul><li><p>建立连接</p></li><li><p>创建Channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel发送消息</p></li><li><p>关闭连接和channel</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PublisherTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;cherishll&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123123&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        Connection connection = factory.newConnection();<br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 3.创建队列</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 4.发送消息</span><br>        String message = <span class="hljs-string">&quot;hello, rabbitmq!&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;发送消息成功：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br>        <span class="hljs-comment">// 5.关闭通道和连接</span><br>        channel.close();<br>        connection.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-1-4-consumer实现"><a href="#1-3-1-4-consumer实现" class="headerlink" title="1.3.1.4 consumer实现"></a>1.3.1.4 consumer实现</h4><ul><li>建立连接</li><li>创建Channel</li><li>利用channel声明队列</li><li>订阅消息<ul><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;cherishll&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123123&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        Connection connection = factory.newConnection();<br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 3.创建队列</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 4.订阅消息</span><br>        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">// 5.处理消息</span><br>                String message = <span class="hljs-keyword">new</span> String(body);<br>                System.out.println(<span class="hljs-string">&quot;接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-总结"><a href="#1-3-2-总结" class="headerlink" title="1.3.2 总结"></a>1.3.2 总结</h3><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="2、SpringAMQP"><a href="#2、SpringAMQP" class="headerlink" title="2、SpringAMQP"></a>2、SpringAMQP</h1><p>SpringAmqp的<a href="https://spring.io/projects/spring-amqp">官方地址</a></p><p>SpringAMQP是基于RabbitMQ封装的一套API规范，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。提供了模板来发送和接收消息，包含两个部分，其中spring-amqp是基础抽象类，spring-rabbit是底层的默认实现。</p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息 </li></ul><h2 id="2-1-Basic-Queue简单队列模型"><a href="#2-1-Basic-Queue简单队列模型" class="headerlink" title="2.1 Basic Queue简单队列模型"></a>2.1 Basic Queue简单队列模型</h2><h3 id="2-1-1-父工程引入AMQP依赖"><a href="#2-1-1-父工程引入AMQP依赖" class="headerlink" title="2.1.1 父工程引入AMQP依赖"></a>2.1.1 父工程引入AMQP依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-消息发送"><a href="#2-1-2-消息发送" class="headerlink" title="2.1.2 消息发送"></a>2.1.2 消息发送</h3><h4 id="2-1-2-1-配置application-yml"><a href="#2-1-2-1-配置application-yml" class="headerlink" title="2.1.2.1 配置application.yml"></a>2.1.2.1 配置application.yml</h4><p>​    首先配置MQ地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">cherishll</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h4 id="2-1-2-2-编写测试类"><a href="#2-1-2-2-编写测试类" class="headerlink" title="2.1.2.2 编写测试类"></a>2.1.2.2 编写测试类</h4><p>在publisher服务中，编写测试类SpringAMQPTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringAmqpTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSimpleQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        String message = <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-3-消息接收"><a href="#2-1-3-消息接收" class="headerlink" title="2.1.3 消息接收"></a>2.1.3 消息接收</h3><h4 id="2-1-3-1-配置application-yml"><a href="#2-1-3-1-配置application-yml" class="headerlink" title="2.1.3.1 配置application.yml"></a>2.1.3.1 配置application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">cherishll</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h4 id="2-1-3-2-编写Rabbit监听"><a href="#2-1-3-2-编写Rabbit监听" class="headerlink" title="2.1.3.2 编写Rabbit监听"></a>2.1.3.2 编写Rabbit监听</h4><p>在consumer服务的<code>cn.lyq.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringRabbitListener</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-4-测试"><a href="#2-1-4-测试" class="headerlink" title="2.1.4 测试"></a>2.1.4 测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="2-2-Work-Queue任务模型"><a href="#2-2-Work-Queue任务模型" class="headerlink" title="2.2 Work Queue任务模型"></a>2.2 Work Queue任务模型</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/img/blogImg/workQueue.png" alt="workQueue"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="2-2-1-消息发送"><a href="#2-2-1-消息发送" class="headerlink" title="2.2.1 消息发送"></a>2.2.1 消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        String queueName = <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        String message = <span class="hljs-string">&quot;hello, message_&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-comment">// 发送消息</span><br>            rabbitTemplate.convertAndSend(queueName, message + i);<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-消息接收"><a href="#2-2-2-消息接收" class="headerlink" title="2.2.2 消息接收"></a>2.2.2 消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenWorkQueue1</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">20</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenWorkQueue2</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="2-2-4-能者多劳"><a href="#2-2-4-能者多劳" class="headerlink" title="2.2.4 能者多劳"></a>2.2.4 能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5 总结"></a>2.2.5 总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="2-3-发布-订阅"><a href="#2-3-发布-订阅" class="headerlink" title="2.3 发布/订阅"></a>2.3 发布/订阅</h2><p>发布订阅的模型如图：</p><p><img src="/img/blogImg/publisherAndConsumer.png" alt="发布订阅"></p><p>可以看到，在订阅模型中，多了一个<strong>exchange角色</strong>，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="2-4-Fanout"><a href="#2-4-Fanout" class="headerlink" title="2.4 Fanout"></a>2.4 Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="/img/blogImg/fanout.png" alt="fanoutQueue"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 exc.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机exc.fanout</li></ul><h3 id="2-4-1-声明队列和交换机"><a href="#2-4-1-声明队列和交换机" class="headerlink" title="2.4.1 声明队列和交换机"></a>2.4.1 声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="/img/blogImg/image-20210717165552676.png" alt="声明"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutConfig</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 声明交换机</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Fanout类型交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">&quot;exc.fanout&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第1个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">fanoutQueue1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindingQueue1</span><span class="hljs-params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第2个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">fanoutQueue2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindingQueue2</span><span class="hljs-params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-4-2-消息发送"><a href="#2-4-2-消息发送" class="headerlink" title="2.4.2 消息发送"></a>2.4.2 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFanoutExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    String exchangeName = <span class="hljs-string">&quot;exc.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    String message = <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-3-消息接收"><a href="#2-4-3-消息接收" class="headerlink" title="2.4.3 消息接收"></a>2.4.3 消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenFanoutQueue1</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenFanoutQueue2</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="2-5-Direct"><a href="#2-5-Direct" class="headerlink" title="2.5 Direct"></a>2.5 Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/img/blogImg/directqueue.png" alt="directQueue"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向exc. direct发送消息</li></ol><h3 id="2-5-1-声明队列和交换机（基于注解）"><a href="#2-5-1-声明队列和交换机（基于注解）" class="headerlink" title="2.5.1 声明队列和交换机（基于注解）"></a>2.5.1 声明队列和交换机（基于注解）</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenDirectQueue1</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenDirectQueue2</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-2-消息发送"><a href="#2-5-2-消息发送" class="headerlink" title="2.5.2 消息发送"></a>2.5.2 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendDirectExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    String exchangeName = <span class="hljs-string">&quot;itcast.direct&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    String message = <span class="hljs-string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;red&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-3-总结"><a href="#2-5-3-总结" class="headerlink" title="2.5.3 总结"></a>2.5.3 总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@QueueBinding</li><li>@Queue</li><li>@Exchange</li></ul><h2 id="2-6-Topic"><a href="#2-6-Topic" class="headerlink" title="2.6 Topic"></a>2.6 Topic</h2><h3 id="2-6-1-说明"><a href="#2-6-1-说明" class="headerlink" title="2.6.1 说明"></a>2.6.1 说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>图示：</p><p> <img src="/img/blogImg/toppicQueue.png" alt="topicQueue"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><h4 id="2-6-1-1-案例需求："><a href="#2-6-1-1-案例需求：" class="headerlink" title="2.6.1.1 案例需求："></a>2.6.1.1 案例需求：</h4><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><h3 id="2-6-2-消息发送"><a href="#2-6-2-消息发送" class="headerlink" title="2.6.2 消息发送"></a>2.6.2 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * topicExchange</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendTopicExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    String exchangeName = <span class="hljs-string">&quot;exc.topic&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    String message = <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-3-消息接收"><a href="#2-6-3-消息接收" class="headerlink" title="2.6.3 消息接收"></a>2.6.3 消息接收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;china.#&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenTopicQueue1</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;exc.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;#.news&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenTopicQueue2</span><span class="hljs-params">(String msg)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-4-总结"><a href="#2-6-4-总结" class="headerlink" title="2.6.4.总结"></a>2.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="2-7-消息转换器"><a href="#2-7-消息转换器" class="headerlink" title="2.7.消息转换器"></a>2.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="2-7-1-测试默认转换器"><a href="#2-7-1-测试默认转换器" class="headerlink" title="2.7.1.测试默认转换器"></a>2.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendMap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 准备消息</span><br>    Map&lt;String,Object&gt; msg = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    msg.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    msg.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;simple.queue&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-2-配置JSON转换器"><a href="#2-7-2-配置JSON转换器" class="headerlink" title="2.7.2.配置JSON转换器"></a>2.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="2-7-2-1-引入依赖"><a href="#2-7-2-1-引入依赖" class="headerlink" title="2.7.2.1 引入依赖"></a>2.7.2.1 引入依赖</h4><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-7-2-2-配置消息转换器"><a href="#2-7-2-2-配置消息转换器" class="headerlink" title="2.7.2.2 配置消息转换器"></a>2.7.2.2 配置消息转换器</h4><p>在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title">jsonMessageConverter</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识MQ</title>
    <link href="/2021/12/07/%E5%88%9D%E8%AF%86MQ/"/>
    <url>/2021/12/07/%E5%88%9D%E8%AF%86MQ/</url>
    
    <content type="html"><![CDATA[<h1 id="1、同步通讯"><a href="#1、同步通讯" class="headerlink" title="1、同步通讯"></a>1、同步通讯</h1><p>​    <strong>同步与异步通讯</strong>：</p><p>​        微服务间通讯有同步和异步两种方式：</p><p>​        同步通讯：就像打电话，需要实时响应。</p><p>​        异步通讯：就像发邮件，不需要马上回复。</p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><p><strong>Feign调用</strong>就属于<strong>同步方式</strong>，虽然调用可以实时得到结果，但<strong>存在</strong>下面的<strong>问题</strong>：</p><ul><li>耦合度高。每次加入新的需求，都要修改原来的代码</li><li>性能下降。调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用时间的总和</li><li>浪费资源。调用链中的每个服务都在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li><li>级联失败。如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li></ul><p>同步调用的<strong>优点</strong>：</p><ul><li>时效性较强，可以立即得到结果</li></ul><h1 id="2、异步通讯"><a href="#2、异步通讯" class="headerlink" title="2、异步通讯"></a>2、异步通讯</h1><p>异步调用常见实现就是事件驱动模式。可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="/img/blogImg/broker.png" alt="事件驱动"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>事件驱动的优势：</p><ul><li>服务解耦。每个服务都可以灵活插拔，可替换</li><li>性能提升，吞吐量提高。无需等待订阅者处理完成，响应更快速</li><li>服务没有强依赖，不用担心级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>流量削峰。不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h1 id="4、MQ常用框架"><a href="#4、MQ常用框架" class="headerlink" title="4、MQ常用框架"></a>4、MQ常用框架</h1><p>MQ（messageQueue），消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的基本使用</title>
    <link href="/2021/12/06/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/06/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1、镜像操作"><a href="#1、镜像操作" class="headerlink" title="1、镜像操作"></a>1、镜像操作</h1><h2 id="1-1-镜像的相关命令"><a href="#1-1-镜像的相关命令" class="headerlink" title="1.1 镜像的相关命令"></a>1.1 镜像的相关命令</h2><p>​    镜像名称：一般分为两部分  [repository]:[tag]   【在没有指定tag时，默认是latest，代表最新版本的镜像】</p><p><img src="/img/blogImg/dockerImage.png" alt="镜像"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images      #查看镜像<br>docker rmi#删除镜像<br>docker pull#从服务拉取镜像<br>docker push#推送镜像到服务<br>docker save #保存镜像为压缩包<br>docker load#加载压缩包为镜像<br>docker build       #基于Dockerfile构建镜像<br></code></pre></td></tr></table></figure><h1 id="2、Docker的容器操作"><a href="#2、Docker的容器操作" class="headerlink" title="2、Docker的容器操作"></a>2、Docker的容器操作</h1><p><img src="/img/blogImg/dockerContiner.png" alt="容器操作"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.6#运行一个容器<br>--name #指定容器名称<br>  -p #指定端口映射<br>  -d 让容器后台运行<br>docker logs #查看容器日志命令，添加-f参数可以持续查看日志<br>docker ps #查看容器状态。添加-a参数查看所有状态的容器<br>docker exec -it [容器名] [要执行的命令] #进入容器执行<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">exec</span>命令可以进入容器修改文件，但是在容器内修改文件是不推荐的</span><br><span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it mn bash <span class="hljs-comment">## 其中bash是一个linux终端交互命令</span></span><br>docker rm  #不能删除运行中的容器，除非添加 -f 参数<br></code></pre></td></tr></table></figure><h2 id="2-1-运行redis容器"><a href="#2-1-运行redis容器" class="headerlink" title="2.1 运行redis容器"></a>2.1 运行redis容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 6379:6379 -v $PWD/data:/data  -d redis:3.2 redis-server --appendonly yes<br><span class="hljs-meta">#</span><span class="bash">-v <span class="hljs-variable">$PWD</span>/data:/data : 将主机中当前目录下的data挂载到容器的/data</span><br><span class="hljs-meta">#</span><span class="bash">redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-简单操作"><a href="#2-1-2-简单操作" class="headerlink" title="2.1.2 简单操作"></a>2.1.2 简单操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it redis bash  #进入redis容器<br>redis-cli#执行redis-cli客户端命令<br></code></pre></td></tr></table></figure><h1 id="3、Docker数据卷"><a href="#3、Docker数据卷" class="headerlink" title="3、Docker数据卷"></a>3、Docker数据卷</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>容器与数据耦合的问题：</p><ul><li>不便于修改。eg: 当我们要修改Nginx的html内容时，需要进入容器内部修改，很不方便。</li><li>数据不可服用。在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。</li><li>升级维护困难。 数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li></ul><p><strong>数据卷</strong>：是一个虚拟目录指向宿主机文件系统中的某个目录（真实目录）。</p><p><img src="/img/blogImg/dockerVolume.png" alt="数据卷"></p><h2 id="3-2-操作数据卷"><a href="#3-2-操作数据卷" class="headerlink" title="3.2 操作数据卷"></a>3.2 操作数据卷</h2><p>数据卷操作的基本语法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><p>​    <code>create</code> 创建一个volume</p><p>​    <code>inspect</code> 显示一个或多个volume的信息</p><p>​    <code>ls</code> 列出所有的volume</p><p>​    <code>prune</code> 删除未使用的volume</p><p>​    <code>rm</code> 删除一个或多个指定的volume</p><blockquote><p>windows中创建的数据卷的地址为(点击<a href="file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/">这里</a>查看)：</p><p>file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/</p></blockquote><h2 id="3-3-挂载数据卷"><a href="#3-3-挂载数据卷" class="headerlink" title="3.3 挂载数据卷"></a>3.3 挂载数据卷</h2><p>创建容器时，可以通过 <code>-v</code> 参数来挂在一个数据卷到某个容器目录。</p><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mynginx -p 8080:8080 -v html:/root/html  -d nginx <br><span class="hljs-meta">#</span><span class="bash">-v html:/root/html 把html数据卷挂载到容器内的/root/html这个目录中</span><br></code></pre></td></tr></table></figure><h3 id="3-3-1-案例-数据卷挂载-："><a href="#3-3-1-案例-数据卷挂载-：" class="headerlink" title="3.3.1 案例(数据卷挂载)："></a>3.3.1 案例(数据卷挂载)：</h3><p>​    创建nginx容器，修改容器内的html目录内的index.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume create html  #创建html数据卷<br>docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br><span class="hljs-meta">#</span><span class="bash"> 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-meta">#</span><span class="bash"> 进入该目录（Linux）</span><br>cd /var/lib/docker/volumes/html/_data<br><span class="hljs-meta">#</span><span class="bash"> 修改文件（Linux）</span><br>vi index.html<br></code></pre></td></tr></table></figure><blockquote><p>windows中关联数据卷，进入</p><p>file://wsl%24/docker-desktop-data/version-pack-data/community/docker/volumes/html/_data目录下，修改index.html</p></blockquote><h3 id="3-3-2-案例-宿主机目录挂载"><a href="#3-3-2-案例-宿主机目录挂载" class="headerlink" title="3.3.2 案例(宿主机目录挂载)"></a>3.3.2 案例(宿主机目录挂载)</h3><p>windows：</p><ul><li>路径盘符要小写</li><li>文件夹名称不能有空格</li><li>文件最好提前创建，不然自动创建出来的是个文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name myNginx -p 80:80 -d -v d:\AppData\docker\volumes\html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure><blockquote><p>​    在计算机的<code>d:\AppData\docker\volumes\html</code>目录下，新增或变更资源，都会同步到nginx的<code>/usr/share/nginx/html</code>目录中</p></blockquote><p>目录挂载与数据卷挂载的语法是类似的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v [宿主机目录]:[容器内目录]<br>-v [宿主机文件]:[容器内文件]<br></code></pre></td></tr></table></figure><h3 id="3-3-3-数据卷挂载与目录直接挂载的区别"><a href="#3-3-3-数据卷挂载与目录直接挂载的区别" class="headerlink" title="3.3.3 数据卷挂载与目录直接挂载的区别"></a>3.3.3 数据卷挂载与目录直接挂载的区别</h3><p>数据卷挂载：(自动化但隐藏细节) 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</p><p>目录挂载: (细节自己实现，没有自动化) 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</p><h1 id="4、Dockerfile自定义镜像"><a href="#4、Dockerfile自定义镜像" class="headerlink" title="4、Dockerfile自定义镜像"></a>4、Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="4-1-镜像结构"><a href="#4-1-镜像结构" class="headerlink" title="4.1 镜像结构"></a>4.1 镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><blockquote><p>底层函数库 -》 环境配置 -》依赖安装 -》应用安装 -》应用配置</p></blockquote><p><img src="/img/blogImg/imageStruct.png" alt="模拟Mysql镜像结构"></p><p>镜像是分层结构，每一层称为一个Layer</p><p>简单来说，镜像就是在系统函数库、运行环境<strong>基础</strong>上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="4-2-Dockerfile语法"><a href="#4-2-Dockerfile语法" class="headerlink" title="4.2 Dockerfile语法"></a>4.2 Dockerfile语法</h2><h3 id="4-2-1-什么是Dockerfile"><a href="#4-2-1-什么是Dockerfile" class="headerlink" title="4.2.1 什么是Dockerfile"></a>4.2.1 什么是Dockerfile</h3><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">指定基础镜像</td><td align="center">FROM centos:6</td></tr><tr><td align="center">ENV</td><td align="center">设置环境变量，可在后面指令使用</td><td align="center">ENV key value</td></tr><tr><td align="center">COPY</td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center">COPY ./mysql-5.7.rpm /tmp</td></tr><tr><td align="center">RUN</td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center">RUN yum install gcc</td></tr><tr><td align="center">EXPOSE</td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>更新详细语法说明，请参考<a href="https://docs.docker.com/engine/reference/builder">官网文档</a></p><h2 id="4-3-构建Java项目"><a href="#4-3-构建Java项目" class="headerlink" title="4.3 构建Java项目"></a>4.3 构建Java项目</h2><h3 id="4-3-1-基于Ubuntu构建Java项目"><a href="#4-3-1-基于Ubuntu构建Java项目" class="headerlink" title="4.3.1 基于Ubuntu构建Java项目"></a>4.3.1 基于Ubuntu构建Java项目</h3><p>​    需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p></li><li><p>步骤2：拷贝docker-demo.jar文件到docker-demo这个目录</p></li><li><p>步骤3：拷贝jdk8.tar.gz文件到docker-demo这个目录</p></li><li><p>步骤4：拷贝Dockerfile到docker-demo这个目录</p></li></ul><p>Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span><br><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure><ul><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><p>构建镜像</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t javaweb:1.0 .<br></code></pre></td></tr></table></figure><h3 id="4-3-2-基于java8构建Java项目"><a href="#4-3-2-基于java8构建Java项目" class="headerlink" title="4.3.2 基于java8构建Java项目"></a>4.3.2 基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs doc">FROM java:8-alpine<br>COPY ./app.jar /tmp/app.jar<br>EXPOSE 8090<br>ENTRYPOINT java -jar /tmp/app.jar<br></code></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h3 id="4-3-3-小结"><a href="#4-3-3-小结" class="headerlink" title="4.3.3 小结"></a>4.3.3 小结</h3><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="5、DockerCompose"><a href="#5、DockerCompose" class="headerlink" title="5、DockerCompose"></a>5、DockerCompose</h1><p>Docker Compose可以基于<strong>Compose文件</strong>帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><h2 id="5-1-初始DockerCompose"><a href="#5-1-初始DockerCompose" class="headerlink" title="5.1 初始DockerCompose"></a>5.1 初始DockerCompose</h2><p>Compose文件是一个<strong>文本文件</strong>，通过<strong>指令</strong>定义集群中的每个容器如何运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> <span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-string">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">environment:</span><br>     <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span> <br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-string">-</span> <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     <span class="hljs-string">-</span> <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-string">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8090:8090&quot;</span><br></code></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考<a href="https://docs.docker.com/compose/compose-file/">官网</a></p><p>其实DockerCompose文件可以看做是将多个<code>docker run</code>命令写到一个文件，只是语法稍有差异。</p><h2 id="5-2-安装DockerCompose"><a href="#5-2-安装DockerCompose" class="headerlink" title="5.2 安装DockerCompose"></a>5.2 安装DockerCompose</h2><p>参考<a href="https://cherishll-git.github.io/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/">docker的介绍与安装</a></p><h2 id="5-3-部署微服务集群"><a href="#5-3-部署微服务集群" class="headerlink" title="5.3 部署微服务集群"></a>5.3 部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h1 id="6、Docker镜像仓库"><a href="#6、Docker镜像仓库" class="headerlink" title="6、Docker镜像仓库"></a>6、Docker镜像仓库</h1><h2 id="6-1搭建私有镜像仓库"><a href="#6-1搭建私有镜像仓库" class="headerlink" title="6.1搭建私有镜像仓库"></a>6.1搭建私有镜像仓库</h2><p>参考<a href="https://cherishll-git.github.io/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/">docker的介绍与安装</a></p><h2 id="6-2-推送、拉取镜像"><a href="#6-2-推送、拉取镜像" class="headerlink" title="6.2 推送、拉取镜像"></a>6.2 推送、拉取镜像</h2><p>推送镜像到<strong>私有镜像</strong>服务<strong>必须先tag</strong>，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的安装</title>
    <link href="/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <url>/2021/12/06/Docker%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Docker基本概念"><a href="#1、Docker基本概念" class="headerlink" title="1、Docker基本概念"></a>1、Docker基本概念</h1><h2 id="1-1-Docker初识"><a href="#1-1-Docker初识" class="headerlink" title="1.1 Docker初识"></a>1.1 Docker初识</h2><p>​    Docker是一个开源的应用容器框架</p><p>​    基于Go语言实现</p><p>​    Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。</p><p>​    容器完全使用<strong>沙箱机制</strong>，相互隔离</p><p>​    容器性能开销极低</p><p>​    <strong>小结：docker是一个容器技术，解决软件跨环境迁移的问题</strong></p><h2 id="1-2-Docker解决兼容性问题"><a href="#1-2-Docker解决兼容性问题" class="headerlink" title="1.2 Docker解决兼容性问题"></a>1.2 Docker解决兼容性问题</h2><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p>为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3 Docker架构"></a>1.3 Docker架构</h2><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。一个镜像可以运行多个容器</p><p>是一个C/S架构的程序，有两部分组成：</p><ul><li>服务端：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>客户端：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><p>Docker的工作流：</p><ul><li><p>构建自定义镜像或者从DockerRegistry拉取镜像</p></li><li><p>根据镜像创建容器，并运行</p></li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4 安装Docker"></a>1.4 安装Docker</h2><h3 id="1-4-1-安装Windows版"><a href="#1-4-1-安装Windows版" class="headerlink" title="1.4.1 安装Windows版"></a>1.4.1 安装Windows版</h3><pre><code>此处参考[博客](https://www.cnblogs.com/wangyang0210/p/13212610.html)</code></pre><h3 id="1-4-2-Linux版-CentOS-7-为例"><a href="#1-4-2-Linux版-CentOS-7-为例" class="headerlink" title="1.4.2 Linux版(CentOS 7 为例)"></a>1.4.2 Linux版(CentOS 7 为例)</h3><p>Docker 分为CE和EE两大版本。</p><p>Linux版：Docker CE支持64位版本CentOS 7，并且要求内核版本不低于3.10，CentOS 7 满足最低内核要求。</p><h4 id="1-4-2-1-卸载（可选）"><a href="#1-4-2-1-卸载（可选）" class="headerlink" title="1.4.2.1 卸载（可选）"></a>1.4.2.1 卸载（可选）</h4><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#反斜杠的作用是连接作用</span></span><br>yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine \<br>                  docker-ce<br></code></pre></td></tr></table></figure><h4 id="1-4-2-2-安装yum工具"><a href="#1-4-2-2-安装yum工具" class="headerlink" title="1.4.2.2 安装yum工具"></a>1.4.2.2 安装yum工具</h4><p>首先需要虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils \<br>           device-mapper-persistent-data \<br>           lvm2 --skip-broken<br></code></pre></td></tr></table></figure><p>更新XFS文件系统管理工具及本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update xfsprogs -y<br></code></pre></td></tr></table></figure><p>然后更新本地镜像源:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#设置docker镜像源</span></span><br>yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>    <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#解决域名问题</span></span><br>sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><h4 id="1-4-2-3-安装docker（ce版本）"><a href="#1-4-2-3-安装docker（ce版本）" class="headerlink" title="1.4.2.3 安装docker（ce版本）"></a>1.4.2.3 安装docker（ce版本）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y docker-ce  ##-y 安装过程中不用询问，问就是yes<br></code></pre></td></tr></table></figure><h4 id="1-4-2-4-启动docker"><a href="#1-4-2-4-启动docker" class="headerlink" title="1.4.2.4 启动docker"></a>1.4.2.4 启动docker</h4><p>Docker应用需要用到各种端口，逐一去修改防火墙设置，会非常麻烦，建议<strong>关闭防火墙</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 关闭</span><br>systemctl stop firewalld<br><span class="hljs-meta">#</span><span class="bash"> 禁止开机启动防火墙</span><br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><p>通过命令启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#启动后查看docker版本</span></span><br>docker --version<br></code></pre></td></tr></table></figure><h4 id="1-4-2-5-配置docker镜像"><a href="#1-4-2-5-配置docker镜像" class="headerlink" title="1.4.2.5 配置docker镜像"></a>1.4.2.5 配置docker镜像</h4><p>docker官方镜像仓库网速较差，我们需要设置国内镜像：</p><p>参考阿里云的<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">镜像加速文档</a></p><h3 id="1-4-3-win10-安装docker-desktop"><a href="#1-4-3-win10-安装docker-desktop" class="headerlink" title="1.4.3 win10 安装docker desktop"></a>1.4.3 win10 安装docker desktop</h3><p>参考<a href="https://www.cnblogs.com/wangyang0210/p/13212610.html">博客</a></p><h1 id="2、安装DockerCompose"><a href="#2、安装DockerCompose" class="headerlink" title="2、安装DockerCompose"></a>2、安装DockerCompose</h1><h2 id="2-1-Linux版本"><a href="#2-1-Linux版本" class="headerlink" title="2.1 Linux版本"></a>2.1 Linux版本</h2><h3 id="2-1-1-下载"><a href="#2-1-1-下载" class="headerlink" title="2.1.1 下载"></a>2.1.1 下载</h3><p>Linux下需要通过命令下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装</span><br>curl -L https://github.com/docker/compose/releases/download/1.29.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="2-1-2-修改文件权限"><a href="#2-1-2-修改文件权限" class="headerlink" title="2.1.2 修改文件权限"></a>2.1.2 修改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改权限</span><br>chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="2-1-3-Base自动补全命令"><a href="#2-1-3-Base自动补全命令" class="headerlink" title="2.1.3 Base自动补全命令"></a>2.1.3 Base自动补全命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 补全命令</span><br>curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose<br></code></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="2-2-Window安装"><a href="#2-2-Window安装" class="headerlink" title="2.2 Window安装"></a>2.2 Window安装</h2><h3 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h3><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><h3 id="2-2-2-安装"><a href="#2-2-2-安装" class="headerlink" title="2.2.2 安装"></a>2.2.2 安装</h3><p>双击下载的安装包直接安装</p><h1 id="3、Docker镜像仓库"><a href="#3、Docker镜像仓库" class="headerlink" title="3、Docker镜像仓库"></a>3、Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1 简化版镜像仓库"></a>3.1 简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --restart=always \<br>    --name registry\<br>    -p 5000:5000 \<br>    -v registry-data:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2 带有图形化界面版本"></a>3.2 带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry</p><p>docker-compose.yml文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./registry-data:/var/lib/registry</span><br>  <span class="hljs-attr">ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">joxit/docker-registry-ui:static</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_TITLE=私有仓库</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_URL=http://registry:5000</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br></code></pre></td></tr></table></figure><p>执行命令构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3 配置Docker信任地址"></a>3.3 配置Docker信任地址</h2><p>我们的私服采用的http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#打开要修改的文件</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment">#添加内容</span><br><span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;http://192.168.150.101:8080&quot;</span>]<br><span class="hljs-comment">#重加载</span><br>systemctl daemon-reload<br><span class="hljs-comment">#重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json字符串与对象的互转</title>
    <link href="/2021/12/03/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E8%BD%AC/"/>
    <url>/2021/12/03/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>在开发过程中，经常需要和别的系统交换数据，数据交换的格式有XML、JSON等，JSON作为一个轻量级的数据格式比xml效率要高，XML需要很多的标签，这无疑占据了网络流量，JSON在这方面则做的很好，下面先看下JSON的格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;JSON&quot;</span>,<span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京市西城区&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">25</span>&#125;<span class="hljs-comment">//JSON的对象格式的字符串</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;com.lyq.pojo.Student&quot;</span>,&#123;<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;211&quot;</span>,<span class="hljs-attr">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-attr">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-attr">&quot;db&quot;</span>:<span class="hljs-string">&quot;mysql&quot;</span>&#125;]<span class="hljs-comment">//数组对象格式</span><br></code></pre></td></tr></table></figure><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>​    要实现JSON与java对象之间的互转，需要借助<strong>第三方jar包</strong>，此处使用json-lib这个jar包，可以冲<a href="https://mvnrepository.com/">此处</a>下载相关jar包，json-lib需要<code>commons-beanutils-1.8.0.jar、commons-collections-3.2.1.jar、commons-lang-2.5.jar、commons-logging-1.1.1.jar、ezmorph-1.0.6.jar </code>五个包的支持。</p><p>json-lib提供了几个类可以完成此功能，例<code>JSONObject、JSONArray</code>从类的名字上可以看出JSONObject转化的应该是对象格式的，而JSONArray转化的则应该是数组对象（即，带[]形式）的。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-lib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>jdk15<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ezmorph<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ezmorph<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、Java普通对象和JSON字符串的互转"><a href="#2、Java普通对象和JSON字符串的互转" class="headerlink" title="2、Java普通对象和JSON字符串的互转"></a>2、Java普通对象和JSON字符串的互转</h2><h3 id="2-1-Java对象-–》Json字符串"><a href="#2-1-Java对象-–》Json字符串" class="headerlink" title="2.1 Java对象 –》Json字符串"></a>2.1 Java对象 –》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String stuno;<br>    <span class="hljs-keyword">private</span> String stuname;<br>    <span class="hljs-keyword">private</span> String stusex;<br>    <span class="hljs-keyword">private</span> String db;<br>    <br>    <span class="hljs-comment">//此处省略setter和getter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    Java对象转Json字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Student对象通过JSONObject和JSONArray两种方式转Json字符串</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertObject</span><span class="hljs-params">()</span> </span>&#123;        <br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;成武&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        JSONObject json = JSONObject.fromObject(stu);<br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray array=JSONArray.fromObject(stu);<br>        <br>        String strJson=json.toString();<br>        String strArray=array.toString();<br>        <br>        System.out.println(<span class="hljs-string">&quot;strJson:&quot;</span>+strJson);<br>        System.out.println(<span class="hljs-string">&quot;strArray:&quot;</span>+strArray);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面为打印结果：</p><blockquote><p>strJson:{“db”:”Mysql”,”id”:3,”stuname”:”成武”,”stuno”:”100”,”stusex”:”M”}<br>strArray:[{“db”:”Mysql”,”id”:3,”stuname”:”成武”,”stuno”:”100”,”stusex”:”M”}]</p></blockquote><p>​    两种方法都可以把java对象转化为JSON字符串，只是转化后的<strong>结构</strong>不同。</p><h3 id="2-2-JSON字符串-—》Java对象"><a href="#2-2-JSON字符串-—》Java对象" class="headerlink" title="2.2 JSON字符串 —》Java对象"></a>2.2 JSON字符串 —》Java对象</h3><p>​    首先需要定义两种不同格式的字符串，需要使用\对双引号进行转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonStrToJava</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//定义两种不同格式的字符串</span><br>        String objectStr=<span class="hljs-string">&quot;&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;李四\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;&quot;</span>;<br>        String arrayStr=<span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;李四\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;]&quot;</span>;<br>    <br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        JSONObject jsonObject=JSONObject.fromObject(objectStr);<br>        Student stu=(Student)JSONObject.toBean(jsonObject, Student.class);<br>        <br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray jsonArray=JSONArray.fromObject(arrayStr);<br>        <span class="hljs-comment">//获得jsonArray的第一个元素</span><br>        Object o=jsonArray.get(<span class="hljs-number">0</span>);<br>        JSONObject jsonObject2=JSONObject.fromObject(o);<br>        Student stu2=(Student)JSONObject.toBean(jsonObject2, Student.class);<br>        System.out.println(<span class="hljs-string">&quot;stu:&quot;</span>+stu);<br>        System.out.println(<span class="hljs-string">&quot;stu2:&quot;</span>+stu2);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面为打印结果：</p><blockquote><p>stu:Student{id=3, stuno=’100’, stuname=’李四’, stusex=’M’, db=’Mysql’}<br>stu2:Student{id=3, stuno=’100’, stuname=’李四’, stusex=’M’, db=’Mysql’}</p></blockquote><p>​    使用<code>JSONObject</code>可以轻松的把JSON格式的字符串转化为java对象，但是使用<code>JSONArray</code>就没那么容易了，因为它有<strong>“[]”</strong>符号，所以我们这里在<strong>获得了JSONArray的对象之后</strong>，<strong>取其第一个元素</strong>即我们需要的一个student的变形，然后使用JSONObject轻松获得</p><h2 id="3、list和json字符串的互转"><a href="#3、list和json字符串的互转" class="headerlink" title="3、list和json字符串的互转"></a>3、<strong>list和json字符串的互转</strong></h2><h3 id="3-1-list-–》Json字符串"><a href="#3-1-list-–》Json字符串" class="headerlink" title="3.1 list –》Json字符串"></a>3.1 list –》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listToJSON</span><span class="hljs-params">()</span></span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;王建&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br>        Student stu2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;102&quot;</span>, <span class="hljs-string">&quot;李承&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        List&lt;Student&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>        lists.add(stu);<br>        lists.add(stu2);<br>        <span class="hljs-comment">//1、使用JSONObject</span><br>        <span class="hljs-comment">//JSONObject listObject=JSONObject.fromObject(lists);//会报错</span><br>        <span class="hljs-comment">//2、使用JSONArray</span><br>        JSONArray listArray=JSONArray.fromObject(lists);<br><br>        <span class="hljs-comment">//System.out.println(&quot;listObject:&quot;+listObject.toString());</span><br>        System.out.println(<span class="hljs-string">&quot;listArray:&quot;</span>+listArray.toString());<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>​    我把使用JSONObject的方式给注掉了，我们先看注释之前的结果：</p><blockquote><p>net.sf.json.JSONException: ‘object’ is an array. Use JSONArray instead</p></blockquote><p>​    注释后，正确执行结果为：</p><blockquote><p>listArray:[{“db”:”Mysql”,”id”:4,”stuname”:”王建”,”stuno”:”101”,”stusex”:”M”},{“db”:”Mysql”,”id”:5,”stuname”:”李承”,”stuno”:”102”,”stusex”:”N”}]</p></blockquote><h3 id="3-2-Json字符串-–》list"><a href="#3-2-Json字符串-–》list" class="headerlink" title="3.2 Json字符串 –》list"></a>3.2 Json字符串 –》list</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonToList</span><span class="hljs-params">()</span></span>&#123;<br>        String arrayStr=<span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:\&quot;4\&quot;,\&quot;stuname\&quot;:\&quot;王建\&quot;,\&quot;stuno\&quot;:\&quot;101\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;]&quot;</span>;<br>        <span class="hljs-comment">//转化为list</span><br>        List&lt;Student&gt; list2=(List&lt;Student&gt;)JSONArray.toList(JSONArray.fromObject(arrayStr), Student.class);<br><br>        <span class="hljs-keyword">for</span> (Student stu : list2) &#123;<br>            System.out.println(stu);<br>        &#125;<br>        <span class="hljs-comment">//转化为数组</span><br>        Student[] ss =(Student[])JSONArray.toArray(JSONArray.fromObject(arrayStr),Student.class);<br>        <span class="hljs-keyword">for</span> (Student student : ss) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;王建&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br>Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;王建&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>由于字符串的格式为带有“[]”的格式，所以这里<strong>选择JSONArray</strong>这个对象，它有<code>toArray、toList</code>方法可供使用，前者转化为java中的<strong>数组</strong>，后者转化为java中的<strong>list</strong>，由于这里有实体类进行对应，所以在使用时指定了泛型的类型（Student.class），这样就可以得到转化后的对象</p><h2 id="4、map和Json字符串的互转"><a href="#4、map和Json字符串的互转" class="headerlink" title="4、map和Json字符串的互转"></a>4、map和Json字符串的互转</h2><h3 id="4-1-Map-—》Json字符串"><a href="#4-1-Map-—》Json字符串" class="headerlink" title="4.1 Map —》Json字符串"></a>4.1 Map —》Json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mapToJSON</span><span class="hljs-params">()</span></span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;成武&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br>        Student stu1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;王建&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Mysql&quot;</span>);<br><br>        HashMap&lt;String, Student&gt; stuMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Student&gt;();<br>        stuMap.put(<span class="hljs-string">&quot;first&quot;</span>,stu);<br>        stuMap.put(<span class="hljs-string">&quot;second&quot;</span>,stu1);<br><br>        <span class="hljs-comment">//1、JSONObject</span><br>        JSONObject mapObject= JSONObject.fromObject(stuMap);<br>        System.out.println(<span class="hljs-string">&quot;mapObject&quot;</span>+mapObject.toString());<br><br>        <span class="hljs-comment">//2、JSONArray</span><br>        JSONArray mapArray=JSONArray.fromObject(stuMap);<br>        System.out.println(<span class="hljs-string">&quot;mapArray:&quot;</span>+mapArray.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mapObject</span>&#123;<span class="hljs-string">&quot;first&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;成武&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;100&quot;</span>&#125;,<span class="hljs-string">&quot;second&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;王建&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;101&quot;</span>&#125;&#125;<br><span class="hljs-attribute">mapArray</span>:[&#123;<span class="hljs-string">&quot;first&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;成武&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;100&quot;</span>&#125;,<span class="hljs-string">&quot;second&quot;</span>:&#123;<span class="hljs-string">&quot;stusex&quot;</span>:<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;stuname&quot;</span>:<span class="hljs-string">&quot;王建&quot;</span>,<span class="hljs-string">&quot;db&quot;</span>:<span class="hljs-string">&quot;Mysql&quot;</span>,<span class="hljs-string">&quot;stuno&quot;</span>:<span class="hljs-string">&quot;101&quot;</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><h3 id="4-2-Json字符串-—》Map"><a href="#4-2-Json字符串-—》Map" class="headerlink" title="4.2 Json字符串 —》Map"></a>4.2 Json字符串 —》Map</h3><p>JSON字符串不能直接转化为map对象，要想取得map中的键对应的值需要别的方式，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Student first;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(Student first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonToMap</span><span class="hljs-params">()</span></span>&#123;<br>        String strObject=<span class="hljs-string">&quot;&#123;\&quot;first\&quot;:&#123;\&quot;id\&quot;:\&quot;3\&quot;,\&quot;stuname\&quot;:\&quot;成武\&quot;,\&quot;stuno\&quot;:\&quot;100\&quot;,\&quot;stusex\&quot;:\&quot;M\&quot;,\&quot;db\&quot;:\&quot;Mysql\&quot;&#125;&#125;&quot;</span>;<br><br>        <span class="hljs-comment">//JSONObject</span><br>        JSONObject jsonObject=JSONObject.fromObject(strObject);<br>        Map map=<span class="hljs-keyword">new</span> HashMap();<br>        map.put(<span class="hljs-string">&quot;first&quot;</span>, Student.class);<br><br>        <span class="hljs-comment">//使用了toBean方法，需要三个参数</span><br>        MyBean my=(MyBean)JSONObject.toBean(jsonObject, MyBean.class, map);<br>        System.out.println(my.getFirst());<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>​    打印结果为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">stuno</span>=<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-attribute">stuname</span>=<span class="hljs-string">&#x27;成武&#x27;</span>, <span class="hljs-attribute">stusex</span>=<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&#x27;Mysql&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>使用toBean()方法是传入了三个参数，第一个是JSONObject对象，第二个是MyBean.class，第三个是一个Map对象。通过MyBean可以知道此类中要有一个first的属性，且其类型为Student，要和map中的键和值类型对应，即，first对应键 first类型对应值的类型。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown的基本使用</title>
    <link href="/2021/12/01/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/01/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Markdown标题"><a href="#1、Markdown标题" class="headerlink" title="1、Markdown标题"></a>1、Markdown标题</h1><h2 id="1-1-使用-和-标记一级和二级标题"><a href="#1-1-使用-和-标记一级和二级标题" class="headerlink" title="1.1 使用 = 和 - 标记一级和二级标题"></a>1.1 使用 = 和 - 标记一级和二级标题</h2><p>= 和 - 标记语法格式如下:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我展示的是一级标题</span><br><span class="hljs-section">=================</span><br><br><span class="hljs-section">我展示的是二级标题</span><br><span class="hljs-section">-----------------</span><br></code></pre></td></tr></table></figure><h2 id="1-2-使用-号标记"><a href="#1-2-使用-号标记" class="headerlink" title="1.2 使用#号标记"></a>1.2 使用#号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><h1 id="2、段落格式"><a href="#2、段落格式" class="headerlink" title="2、段落格式"></a>2、段落格式</h1><h2 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2.1 字体"></a>2.1 字体</h2><p>markdown可以使用一下几种字体</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><h2 id="2-2-分割线"><a href="#2-2-分割线" class="headerlink" title="2.2 分割线"></a>2.2 分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span> <span class="hljs-emphasis">* *</span></span><br><span class="hljs-strong"></span><br><span class="hljs-strong">**</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">- - -</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">----------</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~BAIDU.COM~~<br></code></pre></td></tr></table></figure><p>效果如：<del>BAIDU.COM</del></p><h2 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h2><p>下划线可以通过 HTML 的 <code>^&lt;u&gt;</code> 标签来实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果为： <u>带下划线文本</u></p><h2 id="2-5-注脚"><a href="#2-5-注脚" class="headerlink" title="2.5 注脚"></a>2.5 注脚</h2><p>脚注是对文本的补充说明。Markdown 脚注的格式如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[^要注明的文本]<br></code></pre></td></tr></table></figure><h1 id="3、Markdown-列表"><a href="#3、Markdown-列表" class="headerlink" title="3、Markdown 列表"></a>3、Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p><h2 id="3-1无序列表"><a href="#3-1无序列表" class="headerlink" title="3.1无序列表"></a>3.1无序列表</h2><p>  使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要<strong>添加一个空格</strong>，然后再填写内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><h2 id="3-2有序列表"><a href="#3-2有序列表" class="headerlink" title="3.2有序列表"></a>3.2有序列表</h2><p>  使用数字并加上 . 号来表示，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><h2 id="3-3-列表嵌套"><a href="#3-3-列表嵌套" class="headerlink" title="3.3 列表嵌套"></a>3.3 列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项：<br><span class="hljs-bullet">    -</span> 第一项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第一项嵌套的第二个元素<br><span class="hljs-bullet">2.</span> 第二项：<br><span class="hljs-bullet">    -</span> 第二项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第二项嵌套的第二个元素<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="4、Markdown区块"><a href="#4、Markdown区块" class="headerlink" title="4、Markdown区块"></a>4、Markdown区块</h1><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">区块引用</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">菜鸟教程</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">学的不仅是技术更是梦想</span><br></code></pre></td></tr></table></figure><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">最外层</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; 第一层嵌套</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure><p>展示效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="4-1-区块中使用列表"><a href="#4-1-区块中使用列表" class="headerlink" title="4.1 区块中使用列表"></a>4.1 区块中使用列表</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">区块中使用列表</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第一项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第二项</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><p>显示结果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><h2 id="4-2-列表中使用区块"><a href="#4-2-列表中使用区块" class="headerlink" title="4.2 列表中使用区块"></a>4.2 列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前<strong>添加四个空格</strong>的缩进。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>第一项<br><span class="hljs-code">    &gt; 菜鸟教程</span><br><span class="hljs-code">    &gt; 学的不仅是技术更是梦想</span><br><span class="hljs-bullet">* </span>第二项<br></code></pre></td></tr></table></figure><p>显示效果如下</p><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h1 id="5、Markdown代码"><a href="#5、Markdown代码" class="headerlink" title="5、Markdown代码"></a>5、Markdown代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`printf()` 函数<br></code></pre></td></tr></table></figure><p>显示效果为： <code>printf()</code> 函数</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>也可以使用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><h1 id="6、Markdown-链接"><a href="#6、Markdown-链接" class="headerlink" title="6、Markdown 链接"></a>6、Markdown 链接</h1><h2 id="6-1-使用方法："><a href="#6-1-使用方法：" class="headerlink" title="6.1 使用方法："></a>6.1 使用方法：</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[链接名称]</span>(链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：<code>这是一个链接 [菜鸟教程](https://www.runoob.com)</code><br>效果为：这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>直接使用链接地址： <code>&lt;https://www.runoob.com&gt;</code><br>效果为：<a href="https://www.runoob.com/">https://www.runoob.com</a></p><h2 id="6-2-高级链接"><a href="#6-2-高级链接" class="headerlink" title="6.2 高级链接"></a>6.2 高级链接</h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less">这个链接用 <span class="hljs-selector-tag">1</span> 作为网址变量 <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[1]</span><br>这个链接用 <span class="hljs-selector-tag">runoob</span> 作为网址变量 <span class="hljs-selector-attr">[Runoob]</span><span class="hljs-selector-attr">[runoob]</span><br>然后在文档的结尾为变量赋值（网址）<br><br>  <span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.google.com/</span><br>  <span class="hljs-selector-attr">[runoob]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.runoob.com/</span><br></code></pre></td></tr></table></figure><p>效果为：<br>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="7、Markdown-图片"><a href="#7、Markdown-图片" class="headerlink" title="7、Markdown 图片"></a>7、Markdown 图片</h1><p>Markdown 图片语法格式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址)<br><br>!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址 <span class="hljs-string">&quot;可选标题&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>使用实例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p>显示效果为:<br><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">这个链接用 <span class="hljs-number">1</span> 作为网址变量 [RUNOOB][<span class="hljs-number">1</span>].<br>然后在文档的结尾为变量赋值（网址）<br><br>[<span class="hljs-number">1</span>]: http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png<br></code></pre></td></tr></table></figure><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="8、Markdown-表格"><a href="#8、Markdown-表格" class="headerlink" title="8、Markdown 表格"></a>8、Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行<br>语法格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><p>显示的效果为：<br>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br>对齐方式<br>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。、<br>实例如下：<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure>显示效果为为：<table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/27/hello-world/"/>
    <url>/2021/11/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! 这是hexo自动生成的第一个欢迎也面. 查看 <a href="https://hexo.io/docs/">文档</a> 了解更多信息. 如果您在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">疑难解答</a>中找到答案 ,也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>上询问我.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建一个新的也面"><a href="#创建一个新的也面" class="headerlink" title="创建一个新的也面"></a>创建一个新的也面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动blog服务"><a href="#启动blog服务" class="headerlink" title="启动blog服务"></a>启动blog服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到远端"><a href="#发布到远端" class="headerlink" title="发布到远端"></a>发布到远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
